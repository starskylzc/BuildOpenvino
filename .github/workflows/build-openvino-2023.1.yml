name: build-openvino-2023.1.0-ort-1.16.0-openvinoep-nuget-no-ort-native

on:
  workflow_dispatch:

env:
  OPENVINO_VERSION: "2023.1.0"
  ORT_TAG: "v1.16.0"
  CONFIG: "Release"

  PACKAGE_ID: "Intel.ML.OnnxRuntime.Openvino"
  PACKAGE_VERSION: "1.16.0"
  ORT_MANAGED_DEP_VERSION: "1.16.0"

  MACOSX_DEPLOYMENT_TARGET: "10.15"

  OV_WIN_URL: "https://storage.openvinotoolkit.org/repositories/openvino/packages/2023.1/windows/w_openvino_toolkit_windows_2023.1.0.12185.47b736f63ed_x86_64.zip"
  OV_MAC_URL: "https://storage.openvinotoolkit.org/repositories/openvino/packages/2023.1/macos/m_openvino_toolkit_macos_10_15_2023.1.0.12185.47b736f63ed_x86_64.tgz"

jobs:
  build-win-x64:
    runs-on: windows-2022
    defaults:
      run:
        shell: pwsh
    steps:
      - name: Setup Python (for ORT build scripts + pefile)
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install tools (ninja + vcpkg OpenCL ICD loader + python deps)
        run: |
          $ErrorActionPreference="Stop"
          choco install ninja -y
          git clone --depth 1 https://github.com/microsoft/vcpkg.git vcpkg
          .\vcpkg\bootstrap-vcpkg.bat
          .\vcpkg\vcpkg.exe install opencl:x64-windows
          python -m pip install --upgrade pip
          python -m pip install pefile numpy

      - name: Download & extract OpenVINO prebuilt (win-x64)
        run: |
          $ErrorActionPreference="Stop"
          $zip = Join-Path $env:GITHUB_WORKSPACE "openvino_win.zip"
          Invoke-WebRequest -Uri $env:OV_WIN_URL -OutFile $zip
          Expand-Archive -Path $zip -DestinationPath $env:GITHUB_WORKSPACE -Force
          $ovRoot = Get-ChildItem -Path $env:GITHUB_WORKSPACE -Directory | Where-Object { $_.Name -like "w_openvino_toolkit_windows_*_x86_64" } | Select-Object -First 1
          if (!$ovRoot) { throw "OpenVINO root folder not found after extract." }
          $ovRoot.FullName | Out-File -FilePath "$env:GITHUB_WORKSPACE\ov_root_win.txt" -Encoding ascii

      - name: Clone ONNX Runtime (tag v1.16.0)
        run: |
          $ErrorActionPreference="Stop"
          git clone --branch $env:ORT_TAG --depth 1 --recurse-submodules https://github.com/microsoft/onnxruntime.git onnxruntime

      - name: Build ORT OpenVINO EP provider (win-x64, GPU_FP32)
        run: |
          $ErrorActionPreference="Stop"
          $ovRoot = Get-Content "$env:GITHUB_WORKSPACE\ov_root_win.txt" | Select-Object -First 1
          $ovCmake = Join-Path $ovRoot "runtime\cmake"
          if (!(Test-Path (Join-Path $ovCmake "OpenVINOConfig.cmake"))) { throw "OpenVINOConfig.cmake not found: $ovCmake" }

          $env:INTEL_OPENVINO_DIR = $ovRoot
          $env:OpenVINO_DIR = $ovCmake

          cd onnxruntime
          .\build.bat --config $env:CONFIG --build_shared_lib --parallel --skip_tests --update --build `
            --use_openvino GPU_FP32 `
            --cmake_generator "Visual Studio 17 2022" `
            --cmake_extra_defines OpenVINO_DIR="$ovCmake" `
            --cmake_extra_defines INTEL_OPENVINO_DIR="$ovRoot" `
            --cmake_extra_defines CMAKE_PREFIX_PATH="$ovCmake"

      - name: Stage minimal win-x64 native payload (provider + OpenVINO + TBB + OpenCL ICD loader; no onnxruntime*.dll)
        run: |
          $ErrorActionPreference="Stop"

          $pkgRoot = Join-Path $env:GITHUB_WORKSPACE "pkg"
          $native  = Join-Path $pkgRoot "runtimes\win-x64\native"
          New-Item -ItemType Directory -Force -Path $native | Out-Null

          $ovRoot = Get-Content "$env:GITHUB_WORKSPACE\ov_root_win.txt" | Select-Object -First 1
          $ovBin  = Join-Path $ovRoot "runtime\bin\intel64\Release"
          $ovTbb  = Join-Path $ovRoot "runtime\3rdparty\tbb\bin"
          $vcpkgBin = Join-Path "$env:GITHUB_WORKSPACE\vcpkg" "installed\x64-windows\bin"

          # 1) Provider
          $prov = Get-ChildItem -Path "$env:GITHUB_WORKSPACE\onnxruntime" -Recurse -Filter "onnxruntime_providers_openvino.dll" | Select-Object -First 1
          if (!$prov) { throw "onnxruntime_providers_openvino.dll not found" }
          Copy-Item $prov.FullName $native -Force

          # 2) OpenVINO core + required frontends + plugins (按你提供的官方包真实文件名)
          $must = @(
            "openvino.dll",
            "openvino_c.dll",
            "openvino_ir_frontend.dll",
            "openvino_onnx_frontend.dll",
            "openvino_intel_cpu_plugin.dll",
            "openvino_intel_gpu_plugin.dll",
            "openvino_auto_plugin.dll",
            "openvino_hetero_plugin.dll",
            "openvino_auto_batch_plugin.dll",
            "openvino_gapi_preproc.dll"
          )
          foreach ($n in $must) {
            $p = Join-Path $ovBin $n
            if (!(Test-Path $p)) { throw "Missing OpenVINO binary: $p" }
            Copy-Item $p $native -Force
          }

          # 3) TBB (第三方依赖，官方包里就有)
          $tbbMust = @("tbb12.dll","tbbmalloc.dll","tbbmalloc_proxy.dll","tbbbind_2_5.dll")
          foreach ($n in $tbbMust) {
            $p = Join-Path $ovTbb $n
            if (Test-Path $p) { Copy-Item $p $native -Force }
          }

          # 4) OpenCL ICD Loader (不包含驱动；用户机器装好显卡驱动后即可用)
          $openclDll = Join-Path $vcpkgBin "OpenCL.dll"
          if (Test-Path $openclDll) { Copy-Item $openclDll $native -Force }

          # 5) Dependency closure (只补齐 OpenVINO/TBB/OpenCL 范围内的依赖；禁止拷贝 onnxruntime*.dll)
          $pyFile = Join-Path $env:GITHUB_WORKSPACE "dep_closure_win.py"
          $pyLines = @(
            "import os",
            "import pefile",
            "from collections import deque",
            "",
            "native = r'''$native'''",
            "scan_dirs = [r'''$native''', r'''$ovBin''', r'''$ovTbb''', r'''$vcpkgBin''']",
            "",
            "def is_system(name):",
            "    u = name.upper()",
            "    prefixes = ('KERNEL32','USER32','GDI32','ADVAPI32','SHELL32','OLE32','OLEAUT32','WS2_32','IPHLPAPI','CRYPT32','COMDLG32','SHLWAPI','NTDLL','VERSION','MSVCRT','VCRUNTIME','UCRTBASE','api-ms-win-','ext-ms-win-')",
            "    return u.startswith(prefixes)",
            "",
            "def is_forbidden(name):",
            "    return name.lower().startswith('onnxruntime')",
            "",
            "def find_dll(name):",
            "    p = os.path.join(native, name)",
            "    if os.path.isfile(p): return p",
            "    for d in scan_dirs:",
            "        for root, _, files in os.walk(d):",
            "            for f in files:",
            "                if f.lower() == name.lower():",
            "                    return os.path.join(root, f)",
            "    return None",
            "",
            "def imports(dll_path):",
            "    pe = pefile.PE(dll_path)",
            "    deps = []",
            "    if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):",
            "        for entry in pe.DIRECTORY_ENTRY_IMPORT:",
            "            deps.append(entry.dll.decode(errors='ignore'))",
            "    return deps",
            "",
            "queue = deque([f for f in os.listdir(native) if f.lower().endswith('.dll')])",
            "seen = set(x.lower() for x in queue)",
            "",
            "while queue:",
            "    cur = queue.popleft()",
            "    cur_path = os.path.join(native, cur)",
            "    try:",
            "        deps = imports(cur_path)",
            "    except Exception:",
            "        continue",
            "    for dep in deps:",
            "        if (not dep) or is_system(dep) or is_forbidden(dep):",
            "            continue",
            "        key = dep.lower()",
            "        if key in seen:",
            "            continue",
            "        src = find_dll(dep)",
            "        if not src:",
            "            raise RuntimeError(f'Missing dependency: {dep} (referenced by {cur})')",
            "        base = os.path.basename(src)",
            "        if is_forbidden(base):",
            "            continue",
            "        dst = os.path.join(native, base)",
            "        if not os.path.isfile(dst):",
            "            with open(src, 'rb') as r, open(dst, 'wb') as w:",
            "                w.write(r.read())",
            "        seen.add(base.lower())",
            "        queue.append(base)",
            "",
            "print('Dependency closure complete. DLL count =', len([x for x in os.listdir(native) if x.lower().endswith('.dll')]))"
          )
          Set-Content -Path $pyFile -Value $pyLines -Encoding UTF8
          python $pyFile

          Compress-Archive -Path "$pkgRoot\*" -DestinationPath "$env:GITHUB_WORKSPACE\win-x64-pkg.zip" -Force

      - uses: actions/upload-artifact@v4
        with:
          name: win-x64-pkg
          path: win-x64-pkg.zip

  build-osx-x64:
    runs-on: macos-15-intel
    defaults:
      run:
        shell: bash
    steps:
      - name: Setup Python (for ORT build scripts)
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install build tools
        run: |
          set -euxo pipefail
          brew install cmake ninja

      - name: Download & extract OpenVINO prebuilt (macOS 10.15 x86_64)
        run: |
          set -euxo pipefail
          curl -L "${OV_MAC_URL}" -o openvino_macos.tgz
          tar -xzf openvino_macos.tgz
          ov_root="$(ls -d m_openvino_toolkit_macos_10_15_*_x86_64 | head -n 1)"
          test -d "$ov_root"
          echo "$PWD/$ov_root" > "$GITHUB_WORKSPACE/ov_root_osx.txt"

      - name: Clone ONNX Runtime (tag v1.16.0)
        run: |
          set -euxo pipefail
          git clone --branch "${ORT_TAG}" --depth 1 --recurse-submodules https://github.com/microsoft/onnxruntime.git onnxruntime
          python -m pip install --upgrade pip
          python -m pip install numpy

      - name: Build ORT OpenVINO EP provider (osx-x64, CPU_FP32)
        env:
          MACOSX_DEPLOYMENT_TARGET: "10.15"
        run: |
          set -euxo pipefail
          ov_root="$(cat "$GITHUB_WORKSPACE/ov_root_osx.txt")"
          ov_cmake="$ov_root/runtime/cmake"
          test -f "$ov_cmake/OpenVINOConfig.cmake"

          export INTEL_OPENVINO_DIR="$ov_root"
          export OpenVINO_DIR="$ov_cmake"

          cd onnxruntime
          ./build.sh --config Release --build_shared_lib --parallel --skip_tests --update --build \
            --use_openvino CPU_FP32 \
            --cmake_extra_defines OpenVINO_DIR="$ov_cmake" \
            --cmake_extra_defines INTEL_OPENVINO_DIR="$ov_root" \
            --cmake_extra_defines CMAKE_PREFIX_PATH="$ov_cmake" \
            --cmake_extra_defines CMAKE_OSX_DEPLOYMENT_TARGET=10.15 \
            --cmake_extra_defines CMAKE_OSX_ARCHITECTURES=x86_64

      - name: Stage minimal osx-x64 native payload (provider + OpenVINO + TBB; handle .dylib + .so; patch @loader_path)
        env:
          MACOSX_DEPLOYMENT_TARGET: "10.15"
        run: |
          set -euxo pipefail

          pkg_root="$GITHUB_WORKSPACE/pkg"
          native="$pkg_root/runtimes/osx-x64/native"
          mkdir -p "$native"

          ov_root="$(cat "$GITHUB_WORKSPACE/ov_root_osx.txt")"
          ov_lib="$ov_root/runtime/lib/intel64/Release"
          ov_tbb="$ov_root/runtime/3rdparty/tbb/lib"

          # 1) Provider
          prov="$(find "$GITHUB_WORKSPACE/onnxruntime" -name 'libonnxruntime_providers_openvino.dylib' | head -n 1)"
          test -f "$prov"
          cp -f "$prov" "$native/"

          # 2) OpenVINO core dylibs
          cp -f "$ov_lib/libopenvino.dylib" "$native/"
          cp -f "$ov_lib/libopenvino_c.dylib" "$native/"

          # 3) Frontends (ONNX 必须；IR 一并带上更稳)
          cp -f "$ov_lib"/libopenvino_onnx_frontend*.dylib "$native/" || true
          cp -f "$ov_lib"/libopenvino_ir_frontend*.dylib "$native/" || true

          # 4) Plugins（注意：官方 macOS 包里插件后缀就是 .so）
          for n in \
            libopenvino_intel_cpu_plugin.so \
            libopenvino_auto_plugin.so \
            libopenvino_hetero_plugin.so \
            libopenvino_auto_batch_plugin.so \
            libopenvino_gapi_preproc.so
          do
            test -f "$ov_lib/$n"
            cp -f "$ov_lib/$n" "$native/"
          done

          # 5) TBB thirdparty
          cp -f "$ov_tbb"/libtbb*.dylib "$native/" || true
          cp -f "$ov_tbb"/libtbbmalloc*.dylib "$native/" || true
          cp -f "$ov_tbb"/libtbbmalloc_proxy*.dylib "$native/" || true

          # 6) Dependency closure via otool (include both .dylib and .so), exclude libonnxruntime*
          changed=1
          while [ $changed -eq 1 ]; do
            changed=0
            for lib in "$native"/*; do
              [ -f "$lib" ] || continue
              case "$lib" in
                *.dylib|*.so) ;;
                *) continue ;;
              esac

              while read -r dep _; do
                [ -z "$dep" ] && continue
                case "$dep" in
                  /System/*|/usr/lib/*) continue ;;
                esac
                base="$(basename "$dep")"
                [[ "$base" == libonnxruntime* ]] && continue
                [ -f "$native/$base" ] && continue

                src="$(find "$ov_root" -name "$base" | head -n 1 || true)"
                if [ -n "$src" ] && [ -f "$src" ]; then
                  cp -f "$src" "$native/$base"
                  changed=1
                else
                  echo "Missing dependency: $dep (referenced by $(basename "$lib"))"
                  exit 1
                fi
              done < <(otool -L "$lib" | tail -n +2)
            done
          done

          # 7) Patch install names to @loader_path
          for lib in "$native"/*; do
            [ -f "$lib" ] || continue
            case "$lib" in
              *.dylib|*.so) ;;
              *) continue ;;
            esac
            install_name_tool -id "@rpath/$(basename "$lib")" "$lib" || true
            install_name_tool -add_rpath "@loader_path" "$lib" || true
          done

          for lib in "$native"/*; do
            [ -f "$lib" ] || continue
            case "$lib" in
              *.dylib|*.so) ;;
              *) continue ;;
            esac
            while read -r dep _; do
              [ -z "$dep" ] && continue
              base="$(basename "$dep")"
              if [ -f "$native/$base" ]; then
                install_name_tool -change "$dep" "@loader_path/$base" "$lib" || true
              fi
            done < <(otool -L "$lib" | tail -n +2)
          done

          strip -x "$native"/* || true
          ditto -c -k --sequesterRsrc --keepParent "$pkg_root" "$GITHUB_WORKSPACE/osx-x64-pkg.zip"

      - uses: actions/upload-artifact@v4
        with:
          name: osx-x64-pkg
          path: osx-x64-pkg.zip

  pack-nuget:
    runs-on: ubuntu-latest
    needs: [build-win-x64, build-osx-x64]
    steps:
      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Merge payloads
        run: |
          set -euxo pipefail
          mkdir -p nuget_root
          unzip -q "artifacts/win-x64-pkg/win-x64-pkg.zip" -d nuget_root
          unzip -q "artifacts/osx-x64-pkg/osx-x64-pkg.zip" -d nuget_root
          test -d "nuget_root/pkg/runtimes/win-x64/native"
          test -d "nuget_root/pkg/runtimes/osx-x64/native"

      - name: Create packing project (native-only payload; depends on Managed for version alignment)
        run: |
          set -euxo pipefail
          cd nuget_root/pkg
          cat > "${PACKAGE_ID}.csproj" << EOF
          <Project Sdk="Microsoft.NET.Sdk">
            <PropertyGroup>
              <TargetFramework>netstandard2.0</TargetFramework>
              <PackageId>${PACKAGE_ID}</PackageId>
              <Version>${PACKAGE_VERSION}</Version>
              <Authors>Custom Build</Authors>
              <Description>ONNX Runtime OpenVINO EP provider (ORT ${PACKAGE_VERSION}) + minimal OpenVINO 2023.1 runtime. win-x64: Intel iGPU (GPU_FP32). osx-x64: CPU_FP32. Does NOT include onnxruntime.dll/libonnxruntime.</Description>
              <PackageRequireLicenseAcceptance>false</PackageRequireLicenseAcceptance>
              <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
            </PropertyGroup>

            <ItemGroup>
              <PackageReference Include="Microsoft.ML.OnnxRuntime.Managed" Version="${ORT_MANAGED_DEP_VERSION}" />
            </ItemGroup>

            <ItemGroup>
              <None Include="runtimes/**" Pack="true" PackagePath="runtimes/" />
            </ItemGroup>
          </Project>
          EOF

      - name: Pack nupkg
        run: |
          set -euxo pipefail
          dotnet pack "nuget_root/pkg/${PACKAGE_ID}.csproj" -c Release -o out

      - name: Upload NuGet package
        uses: actions/upload-artifact@v4
        with:
          name: nuget
          path: out/*.nupkg
