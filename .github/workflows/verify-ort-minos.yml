name: Verify ORT NuGet Native Min OS (Windows + macOS) - No Python

on:
  workflow_dispatch:
    inputs:
      start_version:
        description: "Start version (inclusive), e.g. 1.23.2"
        required: true
        default: "1.23.2"
      end_version:
        description: "End version (inclusive), e.g. 1.16.3"
        required: true
        default: "1.16.3"

jobs:
  windows_verify:
    name: Windows - GPU/DirectML packages (min OS inference)
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Prepare directories
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force downloads, extracted, out, tools | Out-Null

      - name: Build ApiMinWin tool
        shell: pwsh
        run: |
          # Expect these 2 files to live at: .github/scripts/ApiMinWin.csproj + .github/scripts/ApiMinWin.cs
          dotnet publish .github/scripts/ApiMinWin.csproj -c Release -o tools/ApiMinWin
          if (!(Test-Path tools/ApiMinWin/ApiMinWin.dll)) { throw "ApiMinWin publish failed." }

      - name: Download Windows.Win32.winmd (Win32Metadata)
        shell: pwsh
        run: |
          $ProgressPreference = "SilentlyContinue"
          $id = "Microsoft.Windows.SDK.Win32Metadata"
          $lower = $id.ToLower()
          $indexUrl = "https://api.nuget.org/v3-flatcontainer/$lower/index.json"
          Write-Host "Fetch win32metadata versions: $indexUrl"
          $versions = (Invoke-RestMethod -Uri $indexUrl -Method Get).versions
          if (-not $versions -or $versions.Count -lt 1) { throw "Could not fetch Win32Metadata versions." }
          $ver = $versions[-1]

          $nupkgUrl = "https://api.nuget.org/v3-flatcontainer/$lower/$ver/$lower.$ver.nupkg"
          $nupkgPath = "downloads\$lower.$ver.nupkg"
          Write-Host "Download: $nupkgUrl"
          Invoke-WebRequest -Uri $nupkgUrl -OutFile $nupkgPath

          $outDir = "extracted\win32metadata.$ver"
          if (Test-Path $outDir) { Remove-Item $outDir -Recurse -Force }
          Expand-Archive -Path $nupkgPath -DestinationPath $outDir -Force

          $winmd = Get-ChildItem $outDir -Recurse -File -Filter "Windows.Win32.winmd" | Select-Object -First 1
          if (-not $winmd) { throw "Windows.Win32.winmd not found inside $nupkgPath" }

          $winmdPath = $winmd.FullName
          "WINMD_PATH=$winmdPath" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          Write-Host "WINMD_PATH = $winmdPath"

      - name: Fetch versions list (NuGet flatcontainer)
        shell: pwsh
        run: |
          $ProgressPreference = "SilentlyContinue"

          function Get-Versions([string]$id) {
            $lower = $id.ToLower()
            $url = "https://api.nuget.org/v3-flatcontainer/$lower/index.json"
            Write-Host "Fetch versions: $url"
            $json = Invoke-RestMethod -Uri $url -Method Get
            return ,$json.versions
          }

          $pkgIds = @(
            "Microsoft.ML.OnnxRuntime.Gpu",
            "Microsoft.ML.OnnxRuntime.Gpu.Windows",
            "Microsoft.ML.OnnxRuntime.DirectML"
          )

          $all = @{}
          foreach ($p in $pkgIds) {
            $all[$p] = Get-Versions $p
            Write-Host "$p versions count = $($all[$p].Count)"
          }

          $all | ConvertTo-Json -Depth 5 | Out-File -Encoding UTF8 out\versions_windows.json

      - name: Build verify list from input range
        shell: pwsh
        run: |
          $start = "${{ inputs.start_version }}"
          $end   = "${{ inputs.end_version }}"

          function Parse-SemVer([string]$v) {
            $v = ($v ?? "").Trim()
            $v = $v -replace "\+.*$", ""
            $core = $v
            $pre  = $null
            if ($v -match "-") {
              $parts = $v.Split('-', 2)
              $core = $parts[0]
              $pre  = $parts[1]
            }
            $nums = @()
            foreach ($seg in $core.Split('.')) {
              if ($seg -match "^(\d+)") { $nums += [int]$Matches[1] } else { $nums += 0 }
            }
            $preIds = @()
            if ($pre) { $preIds = $pre.Split('.') }
            return [PSCustomObject]@{ nums=$nums; pre=$preIds; hasPre=([bool]$pre) }
          }

          function Compare-Pre([string[]]$aPre, [string[]]$bPre) {
            $len = [Math]::Max($aPre.Count, $bPre.Count)
            for ($i=0; $i -lt $len; $i++) {
              if ($i -ge $aPre.Count) { return -1 }
              if ($i -ge $bPre.Count) { return 1 }
              $ai = $aPre[$i]; $bi = $bPre[$i]
              $aIsNum = $ai -match "^\d+$"
              $bIsNum = $bi -match "^\d+$"
              if ($aIsNum -and $bIsNum) {
                $an = [int]$ai; $bn = [int]$bi
                if ($an -lt $bn) { return -1 }
                if ($an -gt $bn) { return 1 }
                continue
              }
              if ($aIsNum -and -not $bIsNum) { return -1 }
              if (-not $aIsNum -and $bIsNum) { return 1 }
              $cmp = [string]::Compare($ai, $bi, $true)
              if ($cmp -lt 0) { return -1 }
              if ($cmp -gt 0) { return 1 }
            }
            return 0
          }

          function Compare-Ver([string]$a, [string]$b) {
            $pa = Parse-SemVer $a
            $pb = Parse-SemVer $b
            $len = [Math]::Max($pa.nums.Count, $pb.nums.Count)
            for ($i=0; $i -lt $len; $i++) {
              $va = if ($i -lt $pa.nums.Count) { $pa.nums[$i] } else { 0 }
              $vb = if ($i -lt $pb.nums.Count) { $pb.nums[$i] } else { 0 }
              if ($va -lt $vb) { return -1 }
              if ($va -gt $vb) { return 1 }
            }
            if (-not $pa.hasPre -and -not $pb.hasPre) { return 0 }
            if (-not $pa.hasPre -and $pb.hasPre) { return 1 }
            if ($pa.hasPre -and -not $pb.hasPre) { return -1 }
            return (Compare-Pre $pa.pre $pb.pre)
          }

          $all = Get-Content out\versions_windows.json -Raw | ConvertFrom-Json

          $pkgIds = @(
            "Microsoft.ML.OnnxRuntime.Gpu",
            "Microsoft.ML.OnnxRuntime.Gpu.Windows",
            "Microsoft.ML.OnnxRuntime.DirectML"
          )

          $list = New-Object System.Collections.Generic.List[object]
          foreach ($p in $pkgIds) {
            foreach ($v in $all.$p) {
              # NOTE: We assume start_version is the newer (upper) bound and end_version is the older (lower) bound.
              if ((Compare-Ver $v $start) -le 0 -and (Compare-Ver $v $end) -ge 0) {
                $list.Add([PSCustomObject]@{ id=$p; version=$v })
              }
            }
          }

          $sorted = $list | Sort-Object id, @{Expression="version";Descending=$true}
          $sorted | ConvertTo-Json -Depth 3 | Out-File -Encoding UTF8 out\verify_windows_list.json

          Write-Host "Verify items count = $($sorted.Count)"
          $sorted | Select-Object -First 20 | Format-Table -AutoSize

      - name: Download & analyze Windows native DLLs (min build)
        shell: pwsh
        run: |
          $ProgressPreference = "SilentlyContinue"

          $tool = (Resolve-Path "tools/ApiMinWin/ApiMinWin.dll").Path
          $winmd = $env:WINMD_PATH
          if (-not $winmd) { throw "WINMD_PATH is empty." }
          if (-not (Test-Path $winmd)) { throw "WINMD_PATH does not exist: $winmd" }

          $items = Get-Content out\verify_windows_list.json -Raw | ConvertFrom-Json
          if (-not $items -or $items.Count -eq 0) { throw "No verify items." }

          $rows = New-Object System.Collections.Generic.List[object]

          foreach ($it in $items) {
            $pkg = [string]$it.id
            $ver = [string]$it.version
            if ([string]::IsNullOrWhiteSpace($pkg) -or [string]::IsNullOrWhiteSpace($ver)) { continue }

            $lower = $pkg.ToLower()
            $nupkg = "downloads\$lower.$ver.nupkg"
            $url = "https://api.nuget.org/v3-flatcontainer/$lower/$ver/$lower.$ver.nupkg"

            if (!(Test-Path $nupkg)) {
              Write-Host "Download: $url"
              Invoke-WebRequest -Uri $url -OutFile $nupkg
            } else {
              Write-Host "Skip download (cached): $nupkg"
            }

            $outdir = "extracted\$lower.$ver"
            if (Test-Path $outdir) { Remove-Item $outdir -Recurse -Force }
            New-Item -ItemType Directory -Force $outdir | Out-Null
            Expand-Archive -Path $nupkg -DestinationPath $outdir -Force

            $dlls = Get-ChildItem $outdir -Recurse -File -Filter "*.dll" |
              Where-Object { $_.FullName -match "\\runtimes\\win-[^\\]+\\native\\" }

            if (-not $dlls -or $dlls.Count -eq 0) {
              Write-Host "No native DLLs found for $pkg $ver (skip)"
              continue
            }

            foreach ($dll in $dlls) {
              $m = [regex]::Match($dll.FullName, "runtimes\\(win-[^\\]+)\\native")
              $rid = if ($m.Success) { $m.Groups[1].Value } else { "UNKNOWN" }

              $json = & dotnet $tool --winmd $winmd --pe $dll.FullName --json
              $res = $json | ConvertFrom-Json

              $rows.Add([PSCustomObject]@{
                package = $pkg
                version = $ver
                runtimeRid = $rid
                pe = $dll.Name
                requiredMinBuild = [int]$res.requiredMinBuild
                requiredMinReason = [string]$res.requiredMinReason
                importCount = [int]$res.importCount
                mappedImportCount = [int]$res.mappedImportCount
              })
            }
          }

          $rows | Export-Csv -NoTypeInformation -Encoding UTF8 out\windows_min_details.csv
          Write-Host "Wrote: out\windows_min_details.csv"

          function Build-ToWindowsName([int]$build) {
            if ($build -le 0) { return "UNKNOWN" }
            $map = [ordered]@{
              7601  = "Windows 7 SP1 (7601)"
              9200  = "Windows 8 (9200)"
              9600  = "Windows 8.1 (9600)"
              10240 = "Windows 10 1507 (10240)"
              10586 = "Windows 10 1511 (10586)"
              14393 = "Windows 10 1607 (14393)"
              15063 = "Windows 10 1703 (15063)"
              16299 = "Windows 10 1709 (16299)"
              17134 = "Windows 10 1803 (17134)"
              17763 = "Windows 10 1809 (17763)"
              18362 = "Windows 10 1903 (18362)"
              18363 = "Windows 10 1909 (18363)"
              19041 = "Windows 10 2004 (19041)"
              19042 = "Windows 10 20H2 (19042)"
              19043 = "Windows 10 21H1 (19043)"
              19044 = "Windows 10 21H2 (19044)"
              19045 = "Windows 10 22H2 (19045)"
              20348 = "Windows Server 2022 (20348)"
              22000 = "Windows 11 21H2 (22000)"
              22621 = "Windows 11 22H2 (22621)"
              22631 = "Windows 11 23H2 (22631)"
              26100 = "Windows 11 24H2 (26100)"
            }
            $keys = $map.Keys | Sort-Object
            $best = ($keys | Where-Object { $_ -le $build } | Select-Object -Last 1)
            return $best ? $map[$best] : ("Windows build $build")
          }

          $summary = $rows |
            Group-Object -Property @{ Expression = { "$($_.package)||$($_.version)" } } |
            ForEach-Object {
              $g = $_.Group
              $pkg = $g[0].package
              $ver = $g[0].version
              $max = ($g | Measure-Object requiredMinBuild -Maximum).Maximum
              $maxReason = ($g | Where-Object { $_.requiredMinBuild -eq $max } | Select-Object -First 1).requiredMinReason
              [PSCustomObject]@{
                package = $pkg
                version = $ver
                requiredMinBuild = [int]$max
                requiredMinWindows = Build-ToWindowsName([int]$max)
                reason = [string]$maxReason
              }
            }

          $summary | Sort-Object package, @{Expression='version'; Descending=$true} |
            Export-Csv -NoTypeInformation -Encoding UTF8 out\windows_min_summary.csv

          Write-Host "Wrote: out\windows_min_summary.csv"
          $summary | Sort-Object package, @{Expression='version'; Descending=$true} | Select-Object -First 30 | Format-Table -AutoSize

      - name: Upload Windows CSV
        uses: actions/upload-artifact@v4
        with:
          name: windows_min_details
          path: out/windows_min_details.csv

      - name: Upload Windows summary CSV
        uses: actions/upload-artifact@v4
        with:
          name: windows_min_summary
          path: out/windows_min_summary.csv

  macos_verify:
    name: macOS - Microsoft.ML.OnnxRuntime (min macOS from Mach-O)
    runs-on: macos-latest

    steps:
      - name: Prepare directories
        shell: bash
        run: |
          mkdir -p downloads extracted out

      - name: Fetch versions list (NuGet flatcontainer)
        shell: bash
        run: |
          ID="microsoft.ml.onnxruntime"
          URL="https://api.nuget.org/v3-flatcontainer/${ID}/index.json"
          curl -L --fail -o out/versions_macos.json "$URL"

      - name: Build verify list from input range
        shell: bash
        run: |
          START="${{ inputs.start_version }}"
          END="${{ inputs.end_version }}"

          ver_le() { [ "$(printf '%s\n' "$1" "$2" | sort -V | head -n1)" = "$1" ]; }
          ver_ge() { [ "$(printf '%s\n' "$1" "$2" | sort -V | tail -n1)" = "$1" ]; }

          jq -r '.versions[]' out/versions_macos.json > out/all_versions.txt

          : > out/verify_macos_list.txt
          while IFS= read -r v; do
            if ver_le "$v" "$START" && ver_ge "$v" "$END"; then
              echo "$v" >> out/verify_macos_list.txt
            fi
          done < out/all_versions.txt

          echo "Verify versions count: $(wc -l < out/verify_macos_list.txt)"
          head -n 20 out/verify_macos_list.txt || true

      - name: Download & analyze (min macOS version)
        shell: bash
        run: |
          PKG_ID="microsoft.ml.onnxruntime"
          echo "package,version,runtimeRid,dylib_or_so,min_macos" > out/macos_min_details.csv

          get_min_macos() {
            local f="$1"
            local min=""
            min="$(otool -l "$f" 2>/dev/null | awk '
              $1=="cmd" && $2=="LC_BUILD_VERSION" {in=1}
              in==1 && $1=="minos" {print $2; exit}
            ' || true)"
            if [[ -z "$min" ]]; then
              min="$(otool -l "$f" 2>/dev/null | awk '
                $1=="cmd" && $2=="LC_VERSION_MIN_MACOSX" {in=1}
                in==1 && $1=="version" {print $2; exit}
              ' || true)"
            fi
            [[ -z "$min" ]] && min="UNKNOWN"
            echo "$min"
          }

          while IFS= read -r ver; do
            [[ -z "$ver" ]] && continue
            echo "==== Microsoft.ML.OnnxRuntime $ver ===="

            nupkg="downloads/${PKG_ID}.${ver}.nupkg"
            url="https://api.nuget.org/v3-flatcontainer/${PKG_ID}/${ver}/${PKG_ID}.${ver}.nupkg"

            if [[ ! -f "$nupkg" ]]; then
              echo "Download: $url"
              curl -L --fail -o "$nupkg" "$url"
            else
              echo "Skip download (cached): $nupkg"
            fi

            outdir="extracted/${PKG_ID}.${ver}"
            rm -rf "$outdir"
            mkdir -p "$outdir"
            unzip -q "$nupkg" -d "$outdir"

            dylibs=()
            while IFS= read -r f; do
              [[ -z "$f" ]] && continue
              dylibs+=("$f")
            done < <(find "$outdir" -type f \( -path "*/runtimes/osx-*/native/*.dylib" -o -path "*/runtimes/osx-*/native/*.so" \) 2>/dev/null || true)

            if [[ ${#dylibs[@]} -eq 0 ]]; then
              echo "No osx native dylib/so found for $ver (skip)"
              continue
            fi

            for f in "${dylibs[@]}"; do
              rid="$(echo "$f" | sed -n 's#.*runtimes/\(osx-[^/]*\)/native/.*#\1#p')"
              base="$(basename "$f")"
              minos="$(get_min_macos "$f")"
              echo "${PKG_ID},${ver},${rid},${base},${minos}" >> out/macos_min_details.csv
            done

          done < out/verify_macos_list.txt

          echo "Wrote: out/macos_min_details.csv"
          head -n 20 out/macos_min_details.csv || true

      - name: Summarize macOS min version per package+version
        shell: bash
        run: |
          set -euo pipefail
          echo "package,version,required_min_macos" > out/macos_min_summary.csv
          tail -n +2 out/macos_min_details.csv \
            | awk -F',' 'NF>=5 {print $1","$2","$5}' \
            | sort -t',' -k1,1 -k2,2 -k3,3V \
            | awk -F',' '{k=$1","$2; last[k]=$3} END {for (k in last) print k","last[k]}' \
            | sort -t',' -k1,1 -k2,2V >> out/macos_min_summary.csv

          echo "Wrote: out/macos_min_summary.csv"
          head -n 30 out/macos_min_summary.csv || true

      - name: Upload macOS CSV
        uses: actions/upload-artifact@v4
        with:
          name: macos_min_details
          path: out/macos_min_details.csv

      - name: Upload macOS summary CSV
        uses: actions/upload-artifact@v4
        with:
          name: macos_min_summary
          path: out/macos_min_summary.csv
