name: Verify ORT NuGet Native Min OS (Windows + macOS) - No Python

on:
  workflow_dispatch:
    inputs:
      start_version:
        description: "Start version (inclusive), e.g. 1.23.2"
        required: true
        default: "1.23.2"
      end_version:
        description: "End version (inclusive), e.g. 1.16.3"
        required: true
        default: "1.16.3"

jobs:
  windows_verify:
    name: Windows - GPU/DirectML packages (min OS inference)
    runs-on: windows-latest

    steps:
      - name: Prepare
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force downloads, extracted, out | Out-Null

      - name: Setup MSVC (dumpbin)
        uses: ilammy/msvc-dev-cmd@v1

      - name: Fetch versions list (NuGet flatcontainer)
        shell: pwsh
        run: |
          $ProgressPreference = "SilentlyContinue"

          function Get-Versions($id) {
            $lower = $id.ToLower()
            $url = "https://api.nuget.org/v3-flatcontainer/$lower/index.json"
            Write-Host "Fetch versions: $url"
            $json = Invoke-RestMethod -Uri $url -Method Get
            return ,$json.versions
          }

          $pkgIds = @(
            "Microsoft.ML.OnnxRuntime.Gpu",
            "Microsoft.ML.OnnxRuntime.Gpu.Windows",
            "Microsoft.ML.OnnxRuntime.DirectML"
          )

          $all = @{}
          foreach ($p in $pkgIds) {
            $all[$p] = Get-Versions $p
            Write-Host "$p versions count = $($all[$p].Count)"
          }

          $all | ConvertTo-Json -Depth 5 | Out-File -Encoding UTF8 out\versions_windows.json

      - name: Build verify list from input range
        shell: pwsh
        run: |
          $start = "${{ inputs.start_version }}"
          $end   = "${{ inputs.end_version }}"

          function Compare-Ver([string]$a, [string]$b) {
            # returns: -1 if a<b, 0 if equal, 1 if a>b
            $pa = $a.Split('.') | ForEach-Object { [int]$_ }
            $pb = $b.Split('.') | ForEach-Object { [int]$_ }
            $len = [Math]::Max($pa.Count, $pb.Count)
            for ($i=0; $i -lt $len; $i++) {
              $va = if ($i -lt $pa.Count) { $pa[$i] } else { 0 }
              $vb = if ($i -lt $pb.Count) { $pb[$i] } else { 0 }
              if ($va -lt $vb) { return -1 }
              if ($va -gt $vb) { return 1 }
            }
            return 0
          }

          $all = Get-Content out\versions_windows.json -Raw | ConvertFrom-Json

          $pkgIds = @(
            "Microsoft.ML.OnnxRuntime.Gpu",
            "Microsoft.ML.OnnxRuntime.Gpu.Windows",
            "Microsoft.ML.OnnxRuntime.DirectML"
          )

          $list = New-Object System.Collections.Generic.List[object]
          foreach ($p in $pkgIds) {
            foreach ($v in $all.$p) {
              if ((Compare-Ver $v $start) -le 0 -and (Compare-Ver $v $end) -ge 0) {
                $list.Add([PSCustomObject]@{ id=$p; version=$v })
              }
            }
          }

          # sort descending by version for readability
          $sorted = $list | Sort-Object id, @{Expression="version";Descending=$true}
          $sorted | ConvertTo-Json -Depth 3 | Out-File -Encoding UTF8 out\verify_windows_list.json

          Write-Host "Verify items count = $($sorted.Count)"
          $sorted | Select-Object -First 20 | Format-Table -AutoSize

      - name: Download & analyze packages (PE headers + imports)
        shell: pwsh
        run: |
          $ProgressPreference = "SilentlyContinue"
          $items = Get-Content out\verify_windows_list.json -Raw | ConvertFrom-Json

          $csv = New-Object System.Collections.Generic.List[string]
          $csv.Add("package,version,runtimeRid,dll,pe_MinOS,pe_Subsystem,pe_SubsystemVer,imports_MinWinGuess")

          function Get-PeHeaderInfo([string]$dllPath) {
            $hdr = (dumpbin /nologo /headers $dllPath) 2>&1
            $minos = ""
            $subsys = ""
            $subver = ""

            foreach ($line in $hdr) {
              if ($line -match "^\s*([0-9]+)\.([0-9]+)\s+operating system version") {
                $minos = "$($Matches[1]).$($Matches[2])"
              }
              if ($line -match "^\s*([0-9]+)\.([0-9]+)\s+subsystem version") {
                $subver = "$($Matches[1]).$($Matches[2])"
              }
              if ($line -match "^\s*Subsystem\s+(.+)$") {
                $subsys = $Matches[1].Trim()
              }
            }

            return @{
              MinOS = $minos
              Subsystem = $subsys
              SubsystemVer = $subver
            }
          }

          function Get-ImportsText([string]$dllPath) {
            $imp = (dumpbin /nologo /imports $dllPath) 2>&1
            return ($imp -join "`n")
          }

          function Guess-MinWinBuild([string]$importsText) {
            # Heuristic sentinels:
            # 1709 (16299): SetUserGeoName (Kernel32)
            # 1809 (17763): DestroySyntheticPointerDevice (User32)
            # 1903 (18362): IsWindowArranged (User32) / Wow64GetThreadContext (Kernel32)
            # 2004 (19041): CoRevokeDeviceCatalog (Combase)
            #
            # If none matched: Unknown(Win10+)
            $hit2004 = ($importsText -match "(?i)\bCoRevokeDeviceCatalog\b")
            $hit1903 = ($importsText -match "(?i)\bIsWindowArranged\b") -or ($importsText -match "(?i)\bWow64(Get|Set)ThreadContext\b")
            $hit1809 = ($importsText -match "(?i)\bDestroySyntheticPointerDevice\b")
            $hit1709 = ($importsText -match "(?i)\bSetUserGeoName\b")

            if ($hit2004) { return "Win10 2004 (19041)+ (by imports)" }
            if ($hit1903) { return "Win10 1903 (18362)+ (by imports)" }
            if ($hit1809) { return "Win10 1809 (17763)+ (by imports)" }
            if ($hit1709) { return "Win10 1709 (16299)+ (by imports)" }
            return "Unknown (likely Win10+; no sentinel matched)"
          }

          foreach ($it in $items) {
            $id = $it.id
            $ver = $it.version
            $lower = $id.ToLower()

            Write-Host "==== $id $ver ===="

            $nupkg = "downloads\$lower.$ver.nupkg"
            $url   = "https://api.nuget.org/v3-flatcontainer/$lower/$ver/$lower.$ver.nupkg"

            if (-not (Test-Path $nupkg)) {
              Write-Host "Download: $url"
              Invoke-WebRequest -Uri $url -OutFile $nupkg
            } else {
              Write-Host "Skip download (cached): $nupkg"
            }

            $outdir = "extracted\$lower.$ver"
            if (Test-Path $outdir) { Remove-Item $outdir -Recurse -Force }
            New-Item -ItemType Directory -Force $outdir | Out-Null
            Expand-Archive -Path $nupkg -DestinationPath $outdir -Force

            # find all native dlls in runtimes/win-*/native
            $nativeDirs = Get-ChildItem -Path $outdir -Recurse -Directory |
              Where-Object { $_.FullName -match "runtimes\\win-(x86|x64|arm64)\\native$" }

            foreach ($nd in $nativeDirs) {
              $rid = ($nd.FullName -replace '.*runtimes\\', '' -replace '\\native$', '')
              $dlls = Get-ChildItem -Path $nd.FullName -Filter *.dll -File

              foreach ($d in $dlls) {
                $pe = Get-PeHeaderInfo $d.FullName
                $impText = Get-ImportsText $d.FullName
                $guess = Guess-MinWinBuild $impText

                $csv.Add(("{0},{1},{2},{3},{4},{5},{6},{7}" -f `
                  $id, $ver, $rid, $d.Name, $pe.MinOS, ($pe.Subsystem -replace ',', ' '), $pe.SubsystemVer, ($guess -replace ',', ' ')))
              }
            }
          }

          $csv | Out-File -Encoding UTF8 out\windows_min_details.csv
          Write-Host "Wrote: out\windows_min_details.csv"

      - name: Upload Windows CSV
        uses: actions/upload-artifact@v4
        with:
          name: windows_min_details
          path: out/windows_min_details.csv

  macos_verify:
    name: macOS - Microsoft.ML.OnnxRuntime (min macOS from Mach-O)
    runs-on: macos-latest

    steps:
      - name: Prepare
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p downloads extracted out

      - name: Fetch versions list (NuGet flatcontainer)
        shell: bash
        run: |
          set -euo pipefail
          ID="microsoft.ml.onnxruntime"
          URL="https://api.nuget.org/v3-flatcontainer/${ID}/index.json"
          echo "Fetch versions: $URL"
          curl -L --fail -o out/versions_macos.json "$URL"

      - name: Build verify list from input range
        shell: bash
        run: |
          set -euo pipefail

          START="${{ inputs.start_version }}"
          END="${{ inputs.end_version }}"

          ver_le() { # a <= b
            [ "$(printf '%s\n' "$1" "$2" | sort -V | head -n1)" = "$1" ]
          }
          ver_ge() { # a >= b
            [ "$(printf '%s\n' "$1" "$2" | sort -V | tail -n1)" = "$1" ]
          }

          jq -r '.versions[]' out/versions_macos.json > out/all_versions.txt

          : > out/verify_macos_list.txt
          while IFS= read -r v; do
            if ver_le "$v" "$START" && ver_ge "$v" "$END"; then
              echo "$v" >> out/verify_macos_list.txt
            fi
          done < out/all_versions.txt

          echo "Verify versions count: $(wc -l < out/verify_macos_list.txt)"
          head -n 20 out/verify_macos_list.txt || true

      - name: Download & analyze (min macOS version)
        shell: bash
        run: |
          set -euo pipefail

          PKG_ID="microsoft.ml.onnxruntime"
          echo "package,version,runtimeRid,dylib_or_so,min_macos" > out/macos_min_details.csv

          # Parse min macOS from Mach-O:
          # Prefer LC_BUILD_VERSION (minos), fallback LC_VERSION_MIN_MACOSX
          get_min_macos() {
            local f="$1"
            local min=""

            # LC_BUILD_VERSION path
            # otool -l prints:
            #   cmd LC_BUILD_VERSION
            #   ...
            #   minos 10.15
            #   sdk 13.3
            min="$(otool -l "$f" 2>/dev/null | awk '
              $1=="cmd" && $2=="LC_BUILD_VERSION" {in=1}
              in==1 && $1=="minos" {print $2; exit}
            ' || true)"

            if [[ -z "$min" ]]; then
              # LC_VERSION_MIN_MACOSX path:
              #   cmd LC_VERSION_MIN_MACOSX
              #   ...
              #   version 10.14
              min="$(otool -l "$f" 2>/dev/null | awk '
                $1=="cmd" && $2=="LC_VERSION_MIN_MACOSX" {in=1}
                in==1 && $1=="version" {print $2; exit}
              ' || true)"
            fi

            if [[ -z "$min" ]]; then
              min="UNKNOWN"
            fi
            echo "$min"
          }

          while IFS= read -r ver; do
            [[ -z "$ver" ]] && continue
            echo "==== Microsoft.ML.OnnxRuntime $ver ===="

            nupkg="downloads/${PKG_ID}.${ver}.nupkg"
            url="https://api.nuget.org/v3-flatcontainer/${PKG_ID}/${ver}/${PKG_ID}.${ver}.nupkg"

            if [[ ! -f "$nupkg" ]]; then
              echo "Download: $url"
              curl -L --fail -o "$nupkg" "$url"
            else
              echo "Skip download (cached): $nupkg"
            fi

            outdir="extracted/${PKG_ID}.${ver}"
            rm -rf "$outdir"
            mkdir -p "$outdir"
            unzip -q "$nupkg" -d "$outdir"

            # Collect dylib/so under runtimes/osx-*/native
            # NOTE: macos runner default bash doesn't have `mapfile`, so use while-read.
            dylibs=()
            while IFS= read -r f; do
              [[ -z "$f" ]] && continue
              dylibs+=("$f")
            done < <(find "$outdir" -type f \( -path "*/runtimes/osx-*/native/*.dylib" -o -path "*/runtimes/osx-*/native/*.so" \) 2>/dev/null || true)

            if [[ ${#dylibs[@]} -eq 0 ]]; then
              echo "No osx native dylib/so found for $ver (skip)"
              continue
            fi

            for f in "${dylibs[@]}"; do
              # rid: extract "osx-x86_64" or "osx-arm64" from path
              rid="$(echo "$f" | sed -n 's#.*runtimes/\(osx-[^/]*\)/native/.*#\1#p')"
              base="$(basename "$f")"
              minos="$(get_min_macos "$f")"
              echo "${PKG_ID},${ver},${rid},${base},${minos}" >> out/macos_min_details.csv
            done

          done < out/verify_macos_list.txt

          echo "Wrote: out/macos_min_details.csv"
          head -n 20 out/macos_min_details.csv || true

      - name: Upload macOS CSV
        uses: actions/upload-artifact@v4
        with:
          name: macos_min_details
          path: out/macos_min_details.csv
