name: Verify ORT NuGet Min OS (native-only, no-python)

on:
  workflow_dispatch:
    inputs:
      min_version:
        description: "Min version (inclusive)"
        required: true
        default: "1.16.3"
      max_version:
        description: "Max version (inclusive)"
        required: true
        default: "1.21.1"

jobs:
  macos_verify:
    name: macOS min version (otool)
    runs-on: macos-latest
    steps:
      - name: Prepare
        shell: bash
        run: |
          set -euxo pipefail
          mkdir -p downloads extracted results
          echo "Runner: $(sw_vers | tr '\n' ' ')"

      - name: Verify macOS dylibs (no python)
        shell: bash
        env:
          MIN_VERSION: ${{ github.event.inputs.min_version }}
          MAX_VERSION: ${{ github.event.inputs.max_version }}
        run: |
          set -euxo pipefail

          PACKAGES=(
            "Microsoft.ML.OnnxRuntime"
            "Microsoft.ML.OnnxRuntime.Gpu"
            "Microsoft.ML.OnnxRuntime.DirectML"
            "Microsoft.ML.OnnxRuntime.Gpu.Windows"
          )

          # ---- helpers ----
          ver_to_num () {
            # "1.21.1" -> 001021001 (lexical comparable)
            local v="$1"
            IFS='.' read -r a b c <<<"$v"
            printf "%03d%03d%03d" "$a" "$b" "$c"
          }

          in_range () {
            local v="$1"
            local min="$2"
            local max="$3"
            local vn mn mx
            vn="$(ver_to_num "$v")"
            mn="$(ver_to_num "$min")"
            mx="$(ver_to_num "$max")"
            [[ "$vn" -ge "$mn" && "$vn" -le "$mx" ]]
          }

          list_versions () {
            # prints sorted desc stable versions within range
            local pkg_lc="$1"
            local idx_url="https://api.nuget.org/v3-flatcontainer/${pkg_lc}/index.json"

            echo ">>> Fetch versions: $idx_url"
            curl -L --fail -o "downloads/${pkg_lc}.index.json" "$idx_url"

            # extract "x.y.z" (ignore prerelease)
            # then filter in range and sort desc numeric
            grep -Eo '"[0-9]+\.[0-9]+\.[0-9]+"' "downloads/${pkg_lc}.index.json" \
              | tr -d '"' \
              | while read -r v; do
                  if in_range "$v" "$MIN_VERSION" "$MAX_VERSION"; then
                    echo "$(ver_to_num "$v") $v"
                  fi
                done \
              | sort -r \
              | awk '{print $2}'
          }

          get_min_macos () {
            # returns "min|TAG"
            local dylib="$1"
            local min=""
            # LC_BUILD_VERSION -> minos
            min="$(otool -l "$dylib" | awk '
              $1=="cmd" && $2=="LC_BUILD_VERSION"{in=1}
              in==1 && $1=="minos"{print $2; exit}
            ')"
            if [[ -n "$min" ]]; then
              echo "${min}|LC_BUILD_VERSION"
              return 0
            fi

            # LC_VERSION_MIN_MACOSX -> version
            min="$(otool -l "$dylib" | awk '
              $1=="cmd" && $2=="LC_VERSION_MIN_MACOSX"{in=1}
              in==1 && $1=="version"{print $2; exit}
            ')"
            if [[ -n "$min" ]]; then
              echo "${min}|LC_VERSION_MIN_MACOSX"
              return 0
            fi

            echo "UNKNOWN|NONE"
          }

          macos_to_num () {
            # "13.3" -> 013003000 ; "10.15.7" -> 010015007
            local s="$1"
            if [[ "$s" == "UNKNOWN" || "$s" == "N/A" || -z "$s" ]]; then
              echo ""
              return 0
            fi
            IFS='.' read -r a b c <<<"$s"
            c="${c:-0}"
            printf "%03d%03d%03d" "$a" "$b" "$c"
          }

          # ---- outputs ----
          echo "package,version,runtime,library,min_macos,tag" > results/macos_min_details.csv
          echo "package,version,worst_min_macos,libs_count,runtimes_count,notes" > results/macos_min_summary.csv

          for pkg in "${PACKAGES[@]}"; do
            pkg_lc="$(echo "$pkg" | tr '[:upper:]' '[:lower:]')"
            echo "=============================="
            echo "PACKAGE: $pkg"
            echo "=============================="

            versions="$(list_versions "$pkg_lc" || true)"
            if [[ -z "${versions}" ]]; then
              echo "WARN: No versions found in range for $pkg"
              continue
            fi

            while read -r ver; do
              [[ -z "$ver" ]] && continue
              echo "---- $pkg $ver ----"

              nupkg="downloads/${pkg_lc}.${ver}.nupkg"
              url="https://api.nuget.org/v3-flatcontainer/${pkg_lc}/${ver}/${pkg_lc}.${ver}.nupkg"

              echo "Download: $url"
              curl -L --fail -o "$nupkg" "$url"

              outdir="extracted/${pkg_lc}.${ver}"
              rm -rf "$outdir"
              mkdir -p "$outdir"
              unzip -q "$nupkg" -d "$outdir"

              # find dylibs
              mapfile -t dylibs < <(find "$outdir" -type f \( -path "*/runtimes/osx-*/native/*.dylib" -o -path "*/runtimes/osx-*/native/*.so" \) 2>/dev/null || true)

              if [[ "${#dylibs[@]}" -eq 0 ]]; then
                echo "NO_OSX_NATIVE"
                echo "${pkg},${ver},N/A,0,0,NO_OSX_NATIVE" >> results/macos_min_summary.csv
                continue
              fi

              worst_num=""
              worst_txt="UNKNOWN"
              libs_count=0
              runtimes_set=""

              for d in "${dylibs[@]}"; do
                libs_count=$((libs_count+1))
                rt="$(echo "$d" | sed -n 's|.*runtimes/\(osx-[^/]*\)/native/.*|\1|p')"
                lib="$(basename "$d")"
                min_tag="$(get_min_macos "$d")"
                min="${min_tag%%|*}"
                tag="${min_tag##*|}"

                echo "  dylib: $rt/$lib -> min_macos=$min ($tag)"
                echo "${pkg},${ver},${rt},${lib},${min},${tag}" >> results/macos_min_details.csv

                # track runtimes
                if [[ "$runtimes_set" != *"|$rt|"* ]]; then
                  runtimes_set="${runtimes_set}|$rt|"
                fi

                num="$(macos_to_num "$min")"
                if [[ -n "$num" ]]; then
                  if [[ -z "$worst_num" || "$num" -gt "$worst_num" ]]; then
                    worst_num="$num"
                    # normalize to a.b.c
                    IFS='.' read -r a b c <<<"$min"
                    c="${c:-0}"
                    worst_txt="${a}.${b}.${c}"
                  fi
                fi
              done

              runtimes_count="$(echo "$runtimes_set" | tr '|' '\n' | grep -E '^osx-' | wc -l | tr -d ' ')"
              notes=""
              if [[ -n "$worst_num" && "$worst_num" -ge "$(macos_to_num "13.3.0")" ]]; then
                notes=">=13.3"
              fi

              echo "SUMMARY: worst_min_macos=$worst_txt libs=$libs_count runtimes=$runtimes_count notes=$notes"
              echo "${pkg},${ver},${worst_txt},${libs_count},${runtimes_count},${notes}" >> results/macos_min_summary.csv

            done <<< "$versions"
          done

          echo "=== DONE macOS ==="
          head -n 50 results/macos_min_summary.csv || true

      - name: Upload artifact (macOS)
        uses: actions/upload-artifact@v4
        with:
          name: ort_min_os_macos
          path: |
            results/macos_min_summary.csv
            results/macos_min_details.csv

  windows_verify:
    name: Windows min OS from PE headers (dumpbin)
    runs-on: windows-latest
    steps:
      - name: Prepare
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force downloads, extracted, results | Out-Null

      - name: Setup MSVC (dumpbin)
        uses: ilammy/msvc-dev-cmd@v1

      - name: Verify Windows DLLs (no python)
        shell: pwsh
        env:
          MIN_VERSION: ${{ github.event.inputs.min_version }}
          MAX_VERSION: ${{ github.event.inputs.max_version }}
        run: |
          $ErrorActionPreference = "Stop"
          $ProgressPreference = "SilentlyContinue"

          $packages = @(
            "Microsoft.ML.OnnxRuntime",
            "Microsoft.ML.OnnxRuntime.Gpu",
            "Microsoft.ML.OnnxRuntime.DirectML"
          )

          function Parse-SemVer3([string]$s) {
            if ($s -match "^\d+\.\d+\.\d+$") { return $s }
            return $null
          }

          function VerToNum([string]$v) {
            $p = $v.Split('.')
            return ([int]$p[0]*1000000 + [int]$p[1]*1000 + [int]$p[2])
          }

          function InRange([string]$v, [string]$min, [string]$max) {
            $vn = VerToNum $v
            $mn = VerToNum $min
            $mx = VerToNum $max
            return ($vn -ge $mn) -and ($vn -le $mx)
          }

          function GetVersionsInRange([string]$pkg, [string]$min, [string]$max) {
            $id = $pkg.ToLower()
            $url = "https://api.nuget.org/v3-flatcontainer/$id/index.json"
            Write-Host ">>> Fetch versions: $url"
            $idx = Invoke-RestMethod -Uri $url
            $vers = @()
            foreach ($s in $idx.versions) {
              $v = Parse-SemVer3 $s
              if ($null -eq $v) { continue }
              if (InRange $v $min $max) { $vers += $v }
            }
            $vers | Sort-Object { VerToNum $_ } -Descending
          }

          function DownloadNupkg([string]$pkg, [string]$ver) {
            $id = $pkg.ToLower()
            $url = "https://api.nuget.org/v3-flatcontainer/$id/$ver/$id.$ver.nupkg"
            $out = "downloads\$id.$ver.nupkg"
            if (-not (Test-Path $out)) {
              Write-Host "Download: $url"
              Invoke-WebRequest -Uri $url -OutFile $out
            }
            return $out
          }

          function ExtractNupkg([string]$nupkg, [string]$dest) {
            if (Test-Path $dest) { Remove-Item -Recurse -Force $dest }
            New-Item -ItemType Directory -Force $dest | Out-Null
            Expand-Archive -Path $nupkg -DestinationPath $dest -Force
          }

          function DumpbinHeaders([string]$dllPath) {
            $txt = (dumpbin /nologo /headers $dllPath) 2>&1
            $osLine = ($txt | Select-String -Pattern "operating system version" | Select-Object -First 1).ToString().Trim()
            $ssLine = ($txt | Select-String -Pattern "subsystem version" | Select-Object -First 1).ToString().Trim()
            return @{ osLine=$osLine; ssLine=$ssLine }
          }

          function ExtractPair([string]$line, [string]$kind) {
            if (-not $line) { return $null }
            if ($kind -eq "os" -and $line -match "(\d+)\.(\d+)\s+operating system version") { return "$($matches[1]).$($matches[2])" }
            if ($kind -eq "ss" -and $line -match "(\d+)\.(\d+)\s+subsystem version") { return "$($matches[1]).$($matches[2])" }
            return $null
          }

          function PairToNum([string]$p) {
            if (-not $p) { return -1 }
            $a = $p.Split('.')
            return ([int]$a[0]*1000 + [int]$a[1])
          }

          function MaxPair([string[]]$pairs) {
            $best = $null
            $bestN = -1
            foreach ($p in $pairs) {
              if (-not $p) { continue }
              $n = PairToNum $p
              if ($n -gt $bestN) { $bestN = $n; $best = $p }
            }
            return $best
          }

          $MIN = $env:MIN_VERSION
          $MAX = $env:MAX_VERSION

          "package,version,runtime,dll,os_version_line,subsystem_version_line,os_pair,subsystem_pair" |
            Out-File -Encoding UTF8 "results\windows_pe_details.csv"
          "package,version,runtimes_count,dlls_count,worst_os_pair,worst_subsystem_pair,notes" |
            Out-File -Encoding UTF8 "results\windows_pe_summary.csv"

          foreach ($pkg in $packages) {
            Write-Host "=============================="
            Write-Host "PACKAGE: $pkg"
            Write-Host "=============================="

            $versions = GetVersionsInRange $pkg $MIN $MAX
            Write-Host "Versions in range [$MIN,$MAX] => $($versions.Count)"
            if ($versions.Count -eq 0) { continue }

            foreach ($ver in $versions) {
              Write-Host "---- $pkg $ver ----"

              $nupkg = DownloadNupkg $pkg $ver
              $dest = "extracted\$($pkg.ToLower()).$ver"
              ExtractNupkg $nupkg $dest

              $nativeDirs = Get-ChildItem -Path $dest -Recurse -Directory |
                Where-Object { $_.FullName -match "runtimes\\win-[^\\]+\\native$" }

              if (-not $nativeDirs) {
                Add-Content "results\windows_pe_summary.csv" "$pkg,$ver,0,0,,,""NO_WIN_NATIVE"""
                continue
              }

              $rtSet = New-Object System.Collections.Generic.HashSet[string]
              $osPairs = @()
              $ssPairs = @()
              $dllCount = 0

              foreach ($nd in $nativeDirs) {
                $runtime = ($nd.FullName -replace ".*runtimes\\(win-[^\\]+)\\native$",'$1')
                [void]$rtSet.Add($runtime)

                $dlls = Get-ChildItem -Path $nd.FullName -Filter *.dll -File
                foreach ($dll in $dlls) {
                  $dllCount++
                  $h = DumpbinHeaders $dll.FullName
                  $osPair = ExtractPair $h.osLine "os"
                  $ssPair = ExtractPair $h.ssLine "ss"
                  if ($osPair) { $osPairs += $osPair }
                  if ($ssPair) { $ssPairs += $ssPair }

                  Write-Host ("  dll: {0}\{1}  os='{2}'  ss='{3}'" -f $runtime, $dll.Name, $h.osLine, $h.ssLine)

                  $osLine = ($h.osLine -replace ",",";")
                  $ssLine = ($h.ssLine -replace ",",";")
                  Add-Content "results\windows_pe_details.csv" "$pkg,$ver,$runtime,$($dll.Name),$osLine,$ssLine,$osPair,$ssPair"
                }
              }

              $worstOs = MaxPair $osPairs
              $worstSs = MaxPair $ssPairs
              $note = ""
              if ($worstSs -eq "10.0") { $note = "Subsystem=10.0 (Win10+)" }

              Add-Content "results\windows_pe_summary.csv" "$pkg,$ver,$($rtSet.Count),$dllCount,$worstOs,$worstSs,""$note"""
              Write-Host "SUMMARY: runtimes=$($rtSet.Count) dlls=$dllCount worst_os=$worstOs worst_ss=$worstSs $note"
            }
          }

          Write-Host "=== DONE Windows ==="
          Get-Content results\windows_pe_summary.csv -TotalCount 60

      - name: Upload artifact (Windows)
        uses: actions/upload-artifact@v4
        with:
          name: ort_min_os_windows
          path: |
            results/windows_pe_summary.csv
            results/windows_pe_details.csv
