name: Verify ORT NuGet Min OS (native-only)

on:
  workflow_dispatch:
    inputs:
      min_version:
        description: "Min version (inclusive)"
        required: true
        default: "1.16.0"
      max_version:
        description: "Max version (inclusive)"
        required: true
        default: "1.23.2"

jobs:
  macos_verify:
    name: macOS min version from dylib headers (otool)
    runs-on: macos-latest
    steps:
      - name: Prepare folders
        shell: bash
        run: |
          set -euxo pipefail
          mkdir -p downloads extracted results
          echo "Runner macOS: $(sw_vers | tr '\n' ' ')"

      - name: Write verifier script (macOS)
        shell: bash
        run: |
          set -euxo pipefail
          cat > verify_macos.py <<'PY'
          import csv
          import json
          import os
          import re
          import shutil
          import subprocess
          import sys
          import urllib.request
          import zipfile
          from pathlib import Path

          PACKAGES = [
              "Microsoft.ML.OnnxRuntime",
              "Microsoft.ML.OnnxRuntime.Gpu",
              "Microsoft.ML.OnnxRuntime.DirectML",
          ]

          MIN = os.environ.get("MIN_VERSION", "1.16.3")
          MAX = os.environ.get("MAX_VERSION", "1.21.1")

          downloads = Path("downloads")
          extracted = Path("extracted")
          results = Path("results")
          downloads.mkdir(parents=True, exist_ok=True)
          extracted.mkdir(parents=True, exist_ok=True)
          results.mkdir(parents=True, exist_ok=True)

          def parse_semver_3(s: str):
              # Accept only stable "x.y.z"
              if not re.match(r"^\d+\.\d+\.\d+$", s):
                  return None
              a,b,c = s.split(".")
              return (int(a), int(b), int(c))

          def semver_cmp(a, b):
              return (a > b) - (a < b)

          def in_range(v, vmin, vmax):
              return semver_cmp(v, vmin) >= 0 and semver_cmp(v, vmax) <= 0

          V_MIN = parse_semver_3(MIN)
          V_MAX = parse_semver_3(MAX)
          if V_MIN is None or V_MAX is None:
              raise SystemExit(f"MIN/MAX must be x.y.z stable versions. Got MIN={MIN}, MAX={MAX}")

          def fetch_json(url: str):
              with urllib.request.urlopen(url) as r:
                  return json.loads(r.read().decode("utf-8"))

          def download_file(url: str, out: Path):
              if out.exists() and out.stat().st_size > 0:
                  return
              with urllib.request.urlopen(url) as r:
                  out.write_bytes(r.read())

          def nuget_index_url(pkg: str) -> str:
              return f"https://api.nuget.org/v3-flatcontainer/{pkg.lower()}/index.json"

          def nuget_nupkg_url(pkg: str, ver: str) -> str:
              p = pkg.lower()
              return f"https://api.nuget.org/v3-flatcontainer/{p}/{ver}/{p}.{ver}.nupkg"

          def list_existing_versions_in_range(pkg: str):
              idx = fetch_json(nuget_index_url(pkg))
              out = []
              for s in idx.get("versions", []):
                  v = parse_semver_3(s)
                  if v is None:
                      continue
                  if in_range(v, V_MIN, V_MAX):
                      out.append(s)
              out.sort(key=lambda x: parse_semver_3(x), reverse=True)
              return out

          def otool_min_macos(dylib: Path):
              try:
                  out = subprocess.check_output(["otool", "-l", str(dylib)], text=True, errors="replace")
              except Exception:
                  return ("UNKNOWN", "OToolFailed")

              # Prefer LC_BUILD_VERSION -> minos
              in_block = False
              for line in out.splitlines():
                  line = line.strip()
                  if line.startswith("cmd ") and "LC_BUILD_VERSION" in line:
                      in_block = True
                      continue
                  if in_block and line.startswith("minos "):
                      return (line.split()[1].strip(), "LC_BUILD_VERSION")
                  if in_block and line.startswith("cmd "):
                      in_block = False

              # Fallback LC_VERSION_MIN_MACOSX -> version
              in_block = False
              for line in out.splitlines():
                  line = line.strip()
                  if line.startswith("cmd ") and "LC_VERSION_MIN_MACOSX" in line:
                      in_block = True
                      continue
                  if in_block and line.startswith("version "):
                      return (line.split()[1].strip(), "LC_VERSION_MIN_MACOSX")
                  if in_block and line.startswith("cmd "):
                      in_block = False

              return ("UNKNOWN", "NO_MIN_TAG")

          def parse_macos_tuple(s: str):
              if not s or s in ("UNKNOWN", "N/A"):
                  return None
              parts = s.split(".")
              try:
                  nums = [int(x) for x in parts[:3]]
                  while len(nums) < 3:
                      nums.append(0)
                  return tuple(nums)
              except:
                  return None

          def fmt_tuple(t):
              if t is None:
                  return "UNKNOWN"
              return f"{t[0]}.{t[1]}.{t[2]}"

          detail_csv = results / "macos_min_details.csv"
          summ_csv   = results / "macos_min_summary.csv"

          with detail_csv.open("w", newline="", encoding="utf-8") as f:
              w = csv.writer(f)
              w.writerow(["package","version","runtime","library","min_macos","tag"])

          with summ_csv.open("w", newline="", encoding="utf-8") as f:
              w = csv.writer(f)
              w.writerow(["package","version","worst_min_macos","libs_count","runtimes_count","notes"])

          for pkg in PACKAGES:
              vers = list_existing_versions_in_range(pkg)
              print(f"== {pkg}: versions in [{MIN},{MAX}] => {len(vers)}")
              if not vers:
                  continue

              for ver in vers:
                  nupkg = downloads / f"{pkg.lower()}.{ver}.nupkg"
                  try:
                      download_file(nuget_nupkg_url(pkg, ver), nupkg)
                  except Exception as e:
                      with summ_csv.open("a", newline="", encoding="utf-8") as f:
                          csv.writer(f).writerow([pkg, ver, "UNKNOWN", 0, 0, "DOWNLOAD_FAIL"])
                      print(f"DOWNLOAD_FAIL {pkg} {ver}: {e}")
                      continue

                  outdir = extracted / f"{pkg.lower()}.{ver}"
                  shutil.rmtree(outdir, ignore_errors=True)
                  outdir.mkdir(parents=True, exist_ok=True)

                  try:
                      with zipfile.ZipFile(nupkg, "r") as z:
                          z.extractall(outdir)
                  except Exception as e:
                      with summ_csv.open("a", newline="", encoding="utf-8") as f:
                          csv.writer(f).writerow([pkg, ver, "UNKNOWN", 0, 0, "EXTRACT_FAIL"])
                      print(f"EXTRACT_FAIL {pkg} {ver}: {e}")
                      continue

                  dylibs = list(outdir.glob("**/runtimes/osx-*/native/*.dylib"))
                  dylibs += list(outdir.glob("**/runtimes/osx-*/native/*.so"))

                  if not dylibs:
                      with summ_csv.open("a", newline="", encoding="utf-8") as f:
                          csv.writer(f).writerow([pkg, ver, "N/A", 0, 0, "NO_OSX_NATIVE"])
                      continue

                  runtimes = set()
                  mins = []

                  for d in dylibs:
                      m, tag = otool_min_macos(d)
                      m_rt = re.search(r"runtimes/(osx-[^/]+)/native", str(d).replace("\\","/"))
                      rt = m_rt.group(1) if m_rt else "UNKNOWN"
                      runtimes.add(rt)

                      with detail_csv.open("a", newline="", encoding="utf-8") as f:
                          csv.writer(f).writerow([pkg, ver, rt, d.name, m, tag])

                      t = parse_macos_tuple(m)
                      if t:
                          mins.append(t)

                  worst = max(mins) if mins else None
                  note = ">=13.3" if (worst and worst >= (13,3,0)) else ""
                  with summ_csv.open("a", newline="", encoding="utf-8") as f:
                      csv.writer(f).writerow([pkg, ver, fmt_tuple(worst), len(dylibs), len(runtimes), note])

          print("DONE macOS.")
          PY

      - name: Run verifier (macOS)
        shell: bash
        env:
          MIN_VERSION: ${{ github.event.inputs.min_version }}
          MAX_VERSION: ${{ github.event.inputs.max_version }}
        run: |
          set -euxo pipefail
          python3 verify_macos.py
          echo "==== macos_min_summary.csv (head) ===="
          head -n 80 results/macos_min_summary.csv || true

      - name: Upload artifact (macOS)
        uses: actions/upload-artifact@v4
        with:
          name: ort_min_os_macos
          path: |
            results/macos_min_summary.csv
            results/macos_min_details.csv

  windows_verify:
    name: Windows OS/SubSystem version from PE headers (dumpbin)
    runs-on: windows-latest
    steps:
      - name: Prepare folders
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force downloads, extracted, results | Out-Null

      - name: Setup MSVC (dumpbin)
        uses: ilammy/msvc-dev-cmd@v1

      - name: Verify (Windows)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $ProgressPreference = "SilentlyContinue"

          $MIN = "${{ github.event.inputs.min_version }}"
          $MAX = "${{ github.event.inputs.max_version }}"

          $packages = @(
            "Microsoft.ML.OnnxRuntime",
            "Microsoft.ML.OnnxRuntime.Gpu",
            "Microsoft.ML.OnnxRuntime.DirectML"
          )

          function Parse-SemVer3([string]$s) {
            if ($s -match "^\d+\.\d+\.\d+$") { return $s }
            return $null
          }

          function Compare-Ver([string]$a, [string]$b) {
            $pa = $a.Split('.') | ForEach-Object { [int]$_ }
            $pb = $b.Split('.') | ForEach-Object { [int]$_ }
            for ($i=0; $i -lt 3; $i++) {
              if ($pa[$i] -lt $pb[$i]) { return -1 }
              if ($pa[$i] -gt $pb[$i]) { return 1 }
            }
            return 0
          }

          function In-Range([string]$v, [string]$min, [string]$max) {
            return ((Compare-Ver $v $min) -ge 0) -and ((Compare-Ver $v $max) -le 0)
          }

          function Get-IndexJson([string]$pkg) {
            $id = $pkg.ToLower()
            $url = "https://api.nuget.org/v3-flatcontainer/$id/index.json"
            (Invoke-RestMethod -Uri $url).versions
          }

          function Download-Nupkg([string]$pkg, [string]$ver) {
            $id = $pkg.ToLower()
            $url = "https://api.nuget.org/v3-flatcontainer/$id/$ver/$id.$ver.nupkg"
            $out = "downloads\$id.$ver.nupkg"
            if (-not (Test-Path $out)) {
              Invoke-WebRequest -Uri $url -OutFile $out
            }
            return $out
          }

          function Extract-Nupkg([string]$nupkg, [string]$dest) {
            if (Test-Path $dest) { Remove-Item -Recurse -Force $dest }
            New-Item -ItemType Directory -Force $dest | Out-Null
            Expand-Archive -Path $nupkg -DestinationPath $dest -Force
          }

          function Dumpbin-Versions([string]$dllPath) {
            $txt = (dumpbin /nologo /headers $dllPath) 2>&1
            $osLine = ($txt | Select-String -Pattern "operating system version" | Select-Object -First 1).ToString().Trim()
            $ssLine = ($txt | Select-String -Pattern "subsystem version" | Select-Object -First 1).ToString().Trim()
            return @{ osLine=$osLine; ssLine=$ssLine }
          }

          function Extract-Pair([string]$line, [string]$kind) {
            if (-not $line) { return $null }
            if ($kind -eq "os" -and $line -match "(\d+)\.(\d+)\s+operating system version") { return "{0}.{1}" -f $matches[1], $matches[2] }
            if ($kind -eq "ss" -and $line -match "(\d+)\.(\d+)\s+subsystem version") { return "{0}.{1}" -f $matches[1], $matches[2] }
            return $null
          }

          function Max-Pair([string[]]$pairs) {
            $best = $null
            foreach ($p in $pairs) {
              if (-not $p) { continue }
              $a = $p.Split('.') | ForEach-Object { [int]$_ }
              if (-not $best) { $best = $p; continue }
              $b = $best.Split('.') | ForEach-Object { [int]$_ }
              if ($a[0] -gt $b[0] -or ($a[0] -eq $b[0] -and $a[1] -gt $b[1])) { $best = $p }
            }
            return $best
          }

          $detail = "results\windows_pe_details.csv"
          $summ   = "results\windows_pe_summary.csv"
          "package,version,runtime,dll,os_version_line,subsystem_version_line,os_pair,subsystem_pair" | Out-File -Encoding UTF8 $detail
          "package,version,runtimes_count,dlls_count,worst_os_pair,worst_subsystem_pair,notes" | Out-File -Encoding UTF8 $summ

          foreach ($pkg in $packages) {
            Write-Host "== $pkg =="

            $all = Get-IndexJson $pkg
            $vers = @()
            foreach ($s in $all) {
              $v = Parse-SemVer3 $s
              if ($null -eq $v) { continue }
              if (In-Range $v $MIN $MAX) { $vers += $v }
            }

            $vers = $vers | Sort-Object {
              $p = $_.Split('.') | ForEach-Object { [int]$_ }
              ($p[0]*1000000 + $p[1]*1000 + $p[2])
            } -Descending

            Write-Host "Versions in range [$MIN,$MAX] => $($vers.Count)"
            if ($vers.Count -eq 0) { continue }

            foreach ($ver in $vers) {
              $nupkg = Download-Nupkg $pkg $ver
              $dest = "extracted\$($pkg.ToLower()).$ver"
              Extract-Nupkg $nupkg $dest

              $nativeDirs = Get-ChildItem -Path $dest -Recurse -Directory |
                Where-Object { $_.FullName -match "runtimes\\win-[^\\]+\\native$" }

              if (-not $nativeDirs) {
                Add-Content $summ "$pkg,$ver,0,0,,,""NO_WIN_NATIVE"""
                continue
              }

              $osPairs = @()
              $ssPairs = @()
              $dllCount = 0
              $rtSet = New-Object System.Collections.Generic.HashSet[string]

              foreach ($nd in $nativeDirs) {
                $runtime = ($nd.FullName -replace ".*runtimes\\(win-[^\\]+)\\native$",'$1')
                [void]$rtSet.Add($runtime)

                $dlls = Get-ChildItem -Path $nd.FullName -Filter *.dll -File
                foreach ($dll in $dlls) {
                  $dllCount++

                  $vinfo = Dumpbin-Versions $dll.FullName
                  $osPair = Extract-Pair $vinfo.osLine "os"
                  $ssPair = Extract-Pair $vinfo.ssLine "ss"
                  if ($osPair) { $osPairs += $osPair }
                  if ($ssPair) { $ssPairs += $ssPair }

                  $osLine = ($vinfo.osLine -replace ",",";")
                  $ssLine = ($vinfo.ssLine -replace ",",";")

                  Add-Content $detail "$pkg,$ver,$runtime,$($dll.Name),$osLine,$ssLine,$osPair,$ssPair"
                }
              }

              $worstOs = Max-Pair $osPairs
              $worstSs = Max-Pair $ssPairs
              $note = ""
              if ($worstSs -eq "10.0") { $note = "Subsystem=10.0 (Win10+)" }

              Add-Content $summ "$pkg,$ver,$($rtSet.Count),$dllCount,$worstOs,$worstSs,""$note"""
            }
          }

      - name: Preview results (Windows)
        shell: pwsh
        run: |
          Write-Host "==== windows_pe_summary.csv (head) ===="
          Get-Content results\windows_pe_summary.csv -TotalCount 100

      - name: Upload artifact (Windows)
        uses: actions/upload-artifact@v4
        with:
          name: ort_min_os_windows
          path: |
            results/windows_pe_summary.csv
            results/windows_pe_details.csv
