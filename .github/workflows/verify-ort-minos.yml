name: Verify ORT NuGet Native Min OS (Windows + macOS) - No Python

on:
  workflow_dispatch:
    inputs:
      start_version:
        description: "Start version (inclusive), e.g. 1.23.2"
        required: true
        default: "1.23.2"
      end_version:
        description: "End version (inclusive), e.g. 1.16.0"
        required: true
        default: "1.16.3"

jobs:
  windows_verify:
    name: Windows - GPU/DirectML packages (min OS via imports+winmd)
    runs-on: windows-latest

    steps:
      - uses: actions/checkout@v4

      - name: Prepare
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force downloads, extracted, out, tools | Out-Null

      - name: Setup MSVC (dumpbin)
        uses: ilammy/msvc-dev-cmd@v1

      - name: Fetch versions list (NuGet flatcontainer)
        shell: pwsh
        run: |
          $ProgressPreference = "SilentlyContinue"

          function Get-Versions($id) {
            $lower = $id.ToLower()
            $url = "https://api.nuget.org/v3-flatcontainer/$lower/index.json"
            Write-Host "Fetch versions: $url"
            $json = Invoke-RestMethod -Uri $url -Method Get
            return ,$json.versions
          }

          $pkgIds = @(
            "Microsoft.ML.OnnxRuntime.Gpu",
            "Microsoft.ML.OnnxRuntime.Gpu.Windows",
            "Microsoft.ML.OnnxRuntime.DirectML"
          )

          $all = @{}
          foreach ($p in $pkgIds) {
            $all[$p] = Get-Versions $p
            Write-Host "$p versions count = $($all[$p].Count)"
          }

          $all | ConvertTo-Json -Depth 5 | Out-File -Encoding UTF8 out\versions_windows.json

      - name: Build verify list from input range
        shell: pwsh
        run: |
          $start = "${{ inputs.start_version }}"
          $end   = "${{ inputs.end_version }}"

          function Parse-SemVer([string]$v) {
            $v = ($v ?? "").Trim()
            $v = $v -replace "\+.*$", ""
            $core = $v
            $pre  = $null
            if ($v -match "-") {
              $parts = $v.Split('-', 2)
              $core = $parts[0]
              $pre  = $parts[1]
            }
            $nums = @()
            foreach ($seg in $core.Split('.')) {
              if ($seg -match "^(\d+)") { $nums += [int]$Matches[1] } else { $nums += 0 }
            }
            $preIds = @()
            if ($pre) { $preIds = $pre.Split('.') }
            return [PSCustomObject]@{ nums=$nums; pre=$preIds; hasPre=([bool]$pre) }
          }

          function Compare-Pre([string[]]$aPre, [string[]]$bPre) {
            $len = [Math]::Max($aPre.Count, $bPre.Count)
            for ($i=0; $i -lt $len; $i++) {
              if ($i -ge $aPre.Count) { return -1 }
              if ($i -ge $bPre.Count) { return 1 }
              $ai = $aPre[$i]; $bi = $bPre[$i]
              $aIsNum = $ai -match "^\d+$"
              $bIsNum = $bi -match "^\d+$"
              if ($aIsNum -and $bIsNum) {
                $an = [int]$ai; $bn = [int]$bi
                if ($an -lt $bn) { return -1 }
                if ($an -gt $bn) { return 1 }
                continue
              }
              if ($aIsNum -and -not $bIsNum) { return -1 }
              if (-not $aIsNum -and $bIsNum) { return 1 }
              $cmp = [string]::Compare($ai, $bi, $true)
              if ($cmp -lt 0) { return -1 }
              if ($cmp -gt 0) { return 1 }
            }
            return 0
          }

          function Compare-Ver([string]$a, [string]$b) {
            $pa = Parse-SemVer $a
            $pb = Parse-SemVer $b
            $len = [Math]::Max($pa.nums.Count, $pb.nums.Count)
            for ($i=0; $i -lt $len; $i++) {
              $va = if ($i -lt $pa.nums.Count) { $pa.nums[$i] } else { 0 }
              $vb = if ($i -lt $pb.nums.Count) { $pb.nums[$i] } else { 0 }
              if ($va -lt $vb) { return -1 }
              if ($va -gt $vb) { return 1 }
            }
            if (-not $pa.hasPre -and -not $pb.hasPre) { return 0 }
            if (-not $pa.hasPre -and $pb.hasPre) { return 1 }
            if ($pa.hasPre -and -not $pb.hasPre) { return -1 }
            return (Compare-Pre $pa.pre $pb.pre)
          }

          $all = Get-Content out\versions_windows.json -Raw | ConvertFrom-Json

          $pkgIds = @(
            "Microsoft.ML.OnnxRuntime.Gpu",
            "Microsoft.ML.OnnxRuntime.Gpu.Windows",
            "Microsoft.ML.OnnxRuntime.DirectML"
          )

          $list = New-Object System.Collections.Generic.List[object]
          foreach ($p in $pkgIds) {
            foreach ($v in $all.$p) {
              if ((Compare-Ver $v $start) -le 0 -and (Compare-Ver $v $end) -ge 0) {
                $list.Add([PSCustomObject]@{ id=$p; version=$v })
              }
            }
          }

          $sorted = $list | Sort-Object id, @{Expression="version";Descending=$true}
          $sorted | ConvertTo-Json -Depth 3 | Out-File -Encoding UTF8 out\verify_windows_list.json

          Write-Host "Verify items count = $($sorted.Count)"
          $sorted | Select-Object -First 20 | Format-Table -AutoSize

      - name: Download Win32 metadata (Microsoft.Windows.SDK.NET) - get Windows.Win32.winmd
        shell: pwsh
        run: |
          $ProgressPreference = "SilentlyContinue"

          $id = "microsoft.windows.sdk.net"
          $indexUrl = "https://api.nuget.org/v3-flatcontainer/$id/index.json"
          Write-Host "Fetch: $indexUrl"
          $vers = (Invoke-RestMethod -Uri $indexUrl -Method Get).versions
          $stable = $vers | Where-Object { $_ -notmatch "-" }
          $ver = $stable[-1]
          Write-Host "Use Microsoft.Windows.SDK.NET version = $ver"

          $nupkg = "downloads\$id.$ver.nupkg"
          $pkgUrl = "https://api.nuget.org/v3-flatcontainer/$id/$ver/$id.$ver.nupkg"
          Write-Host "Download: $pkgUrl"
          Invoke-WebRequest -Uri $pkgUrl -OutFile $nupkg

          $sdkDir = "tools\sdknet.$ver"
          if (Test-Path $sdkDir) { Remove-Item $sdkDir -Recurse -Force }
          New-Item -ItemType Directory -Force $sdkDir | Out-Null
          Expand-Archive -Path $nupkg -DestinationPath $sdkDir -Force

          $winmd = Get-ChildItem -Path $sdkDir -Recurse -Filter "Windows.Win32.winmd" -File | Select-Object -First 1
          if (-not $winmd) { throw "Windows.Win32.winmd not found in Microsoft.Windows.SDK.NET package" }

          $winmd.FullName | Out-File -Encoding UTF8 "out\win32_winmd_path.txt"
          Write-Host "Windows.Win32.winmd: $($winmd.FullName)"
          Write-Host "Saved: out\win32_winmd_path.txt"

      - name: Build ApiMinWin tool (from repo .github/scripts)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $srcCs  = ".github\scripts\ApiMinWin.cs"
          $srcPrj = ".github\scripts\ApiMinWin.csproj"
          if (-not (Test-Path $srcCs))  { throw "Missing $srcCs" }
          if (-not (Test-Path $srcPrj)) { throw "Missing $srcPrj" }

          $toolDir = "tools\ApiMinWin"
          if (Test-Path $toolDir) { Remove-Item $toolDir -Recurse -Force }
          New-Item -ItemType Directory -Force $toolDir | Out-Null

          Copy-Item $srcPrj -Destination (Join-Path $toolDir "ApiMinWin.csproj") -Force
          Copy-Item $srcCs  -Destination (Join-Path $toolDir "Program.cs") -Force

          Write-Host "Build ApiMinWin..."
          dotnet build "$toolDir\ApiMinWin.csproj" -c Release

          $exe = Join-Path $toolDir "bin\Release\net8.0\ApiMinWin.exe"
          if (-not (Test-Path $exe)) { throw "ApiMinWin.exe not found at $exe" }
          Write-Host "ApiMinWin.exe: $exe"

      - name: Download & analyze packages (PE headers + imports->winmd min build)
        shell: pwsh
        run: |
          $ProgressPreference = "SilentlyContinue"
          $ErrorActionPreference = "Stop"

          $items = Get-Content out\verify_windows_list.json -Raw | ConvertFrom-Json
          $winmdPath = (Get-Content out\win32_winmd_path.txt -Raw).Trim()
          if (-not (Test-Path $winmdPath)) { throw "winmd not found: $winmdPath" }

          $apiExe = "tools\ApiMinWin\bin\Release\net8.0\ApiMinWin.exe"
          if (-not (Test-Path $apiExe)) { throw "ApiMinWin.exe not found: $apiExe" }

          $csv = New-Object System.Collections.Generic.List[string]
          $csv.Add("package,version,runtimeRid,dll,pe_MinOS,pe_Subsystem,pe_SubsystemVer,api_MinWinBuild,api_MinWinReason")

          function Get-PeHeaderInfo([string]$dllPath) {
            $hdr = (dumpbin /nologo /headers $dllPath) 2>&1
            $minos = ""
            $subsys = ""
            $subver = ""
            foreach ($line in $hdr) {
              if ($line -match "^\s*([0-9]+)\.([0-9]+)\s+operating system version") {
                $minos = "$($Matches[1]).$($Matches[2])"
              }
              if ($line -match "^\s*([0-9]+)\.([0-9]+)\s+subsystem version") {
                $subver = "$($Matches[1]).$($Matches[2])"
              }
              if ($line -match "^\s*Subsystem\s+(.+)$") {
                $subsys = $Matches[1].Trim()
              }
            }
            return @{
              MinOS = $minos
              Subsystem = $subsys
              SubsystemVer = $subver
            }
          }

          function Get-ImportPairs([string]$dllPath) {
            # Parse dumpbin /imports into lines "dll,func"
            $lines = (dumpbin /nologo /imports $dllPath) 2>&1
            $pairs = New-Object System.Collections.Generic.List[string]
            $curDll = $null

            foreach ($raw in $lines) {
              $line = ($raw ?? "").TrimEnd()

              # DLL header lines: e.g. "KERNEL32.dll"
              if ($line -match "^\s*([A-Za-z0-9_\-\.]+\.dll)$") {
                $curDll = $Matches[1].ToLowerInvariant()
                continue
              }

              if (-not $curDll) { continue }

              # Common import name lines: "7F8  GetLastError" (hint hex + name)
              if ($line -match "^\s*[0-9A-Fa-f]+\s+([A-Za-z0-9_@\?\$]+)$") {
                $fn = $Matches[1]
                # skip noisy pseudo symbols
                if ($fn -match "^(?:__imp_|_imp__|@)" ) { continue }
                $pairs.Add("$curDll,$fn")
                continue
              }

              # Some dumpbin versions print: "ordinal hint name"
              # e.g. "    12    7F8  GetLastError"
              if ($line -match "^\s*\d+\s+[0-9A-Fa-f]+\s+([A-Za-z0-9_@\?\$]+)$") {
                $fn = $Matches[1]
                if ($fn -match "^(?:__imp_|_imp__|@)" ) { continue }
                $pairs.Add("$curDll,$fn")
                continue
              }
            }

            return $pairs
          }

          function Get-MinBuildFromImports([string[]]$pairs) {
            if (-not $pairs -or $pairs.Count -eq 0) {
              return @{ Build = 0; Reason = "" }
            }

            # Feed into ApiMinWin: outputs csv "dll,func,minBuild,reason"
            $outLines = $pairs | & $apiExe $winmdPath 2>$null
            if (-not $outLines -or $outLines.Count -lt 2) {
              return @{ Build = 0; Reason = "" }
            }

            $rows = $outLines | ConvertFrom-Csv
            $max = 0
            $reason = ""

            foreach ($r in $rows) {
              $b = 0
              if ($r.minBuild -match "^\d+$") { $b = [int]$r.minBuild }
              if ($b -gt $max) {
                $max = $b
                $reason = $r.reason
              }
            }
            return @{ Build = $max; Reason = $reason }
          }

          foreach ($it in $items) {
            $id = $it.id
            $ver = $it.version
            $lower = $id.ToLower()

            Write-Host "==== $id $ver ===="

            $nupkg = "downloads\$lower.$ver.nupkg"
            $url   = "https://api.nuget.org/v3-flatcontainer/$lower/$ver/$lower.$ver.nupkg"

            if (-not (Test-Path $nupkg)) {
              Write-Host "Download: $url"
              Invoke-WebRequest -Uri $url -OutFile $nupkg
            } else {
              Write-Host "Skip download (cached): $nupkg"
            }

            $outdir = "extracted\$lower.$ver"
            if (Test-Path $outdir) { Remove-Item $outdir -Recurse -Force }
            New-Item -ItemType Directory -Force $outdir | Out-Null
            Expand-Archive -Path $nupkg -DestinationPath $outdir -Force

            $nativeDirs = Get-ChildItem -Path $outdir -Recurse -Directory |
              Where-Object { $_.FullName -match "runtimes\\win-(x86|x64|arm64)\\native$" }

            foreach ($nd in $nativeDirs) {
              $rid = ($nd.FullName -replace '.*runtimes\\', '' -replace '\\native$', '')
              $dlls = Get-ChildItem -Path $nd.FullName -Filter *.dll -File

              foreach ($d in $dlls) {
                $pe = Get-PeHeaderInfo $d.FullName
                $pairs = Get-ImportPairs $d.FullName
                $minApi = Get-MinBuildFromImports $pairs

                $apiBuild = if ($minApi.Build -gt 0) { "$($minApi.Build)" } else { "UNKNOWN" }
                $apiReason = ($minApi.Reason ?? "") -replace ",", " "

                $csv.Add(("{0},{1},{2},{3},{4},{5},{6},{7},{8}" -f `
                  ($id -replace ","," "), `
                  ($ver -replace ","," "), `
                  ($rid -replace ","," "), `
                  ($d.Name -replace ","," "), `
                  ($pe.MinOS -replace ","," "), `
                  (($pe.Subsystem -replace ","," ") ?? ""), `
                  ($pe.SubsystemVer -replace ","," "), `
                  $apiBuild, `
                  $apiReason
                ))
              }
            }
          }

          $csv | Out-File -Encoding UTF8 out\windows_min_details.csv
          Write-Host "Wrote: out\windows_min_details.csv"

      - name: Summarize Windows min OS per package+version
        shell: pwsh
        run: |
          $rows = Import-Csv out\windows_min_details.csv

          function Parse-MajorMinor([string]$s) {
            if ([string]::IsNullOrWhiteSpace($s)) { return $null }
            if ($s -match "^(\d+)\.(\d+)") {
              return [PSCustomObject]@{ Major=[int]$Matches[1]; Minor=[int]$Matches[2] }
            }
            return $null
          }

          function Cmp-MajorMinor($a, $b) {
            if ($null -eq $a -and $null -eq $b) { return 0 }
            if ($null -eq $a) { return -1 }
            if ($null -eq $b) { return 1 }
            if ($a.Major -ne $b.Major) { return [Math]::Sign($a.Major - $b.Major) }
            return [Math]::Sign($a.Minor - $b.Minor)
          }

          function Max-MajorMinor($vals) {
            $max = $null
            foreach ($v in $vals) {
              if (Cmp-MajorMinor $v $max -gt 0) { $max = $v }
            }
            return $max
          }

          $summary = $rows |
            Group-Object package,version |
            ForEach-Object {
              $grp = $_.Group
              $peMin = Max-MajorMinor ($grp | ForEach-Object { Parse-MajorMinor $_.pe_MinOS })
              $subMin = Max-MajorMinor ($grp | ForEach-Object { Parse-MajorMinor $_.pe_SubsystemVer })

              $maxApiBuild = ($grp | ForEach-Object {
                if ($_.api_MinWinBuild -match "^\d+$") { [int]$_.api_MinWinBuild } else { 0 }
              } | Measure-Object -Maximum).Maximum

              $bestReason = ($grp | Where-Object { $_.api_MinWinBuild -eq "$maxApiBuild" } | Select-Object -First 1).api_MinWinReason

              $peStr  = if ($peMin) { "{0}.{1}" -f $peMin.Major, $peMin.Minor } else { "UNKNOWN" }
              $subStr = if ($subMin) { "{0}.{1}" -f $subMin.Major, $subMin.Minor } else { "UNKNOWN" }

              [PSCustomObject]@{
                package = $grp[0].package
                version = $grp[0].version
                required_pe_MinOS = $peStr
                required_pe_SubsystemVer = $subStr
                api_based_min_win_build = if ($maxApiBuild -gt 0) { $maxApiBuild } else { "UNKNOWN" }
                api_based_reason = $bestReason
              }
            }

          $summary | Sort-Object package, version | Export-Csv -NoTypeInformation -Encoding UTF8 out\windows_min_summary.csv
          Write-Host "Wrote: out\windows_min_summary.csv"
          $summary | Sort-Object package, @{Expression='version'; Descending=$true} | Select-Object -First 30 | Format-Table -AutoSize

      - name: Upload Windows CSV
        uses: actions/upload-artifact@v4
        with:
          name: windows_min_details
          path: out/windows_min_details.csv

      - name: Upload Windows summary CSV
        uses: actions/upload-artifact@v4
        with:
          name: windows_min_summary
          path: out/windows_min_summary.csv

  macos_verify:
    name: macOS - Microsoft.ML.OnnxRuntime (min macOS from Mach-O)
    runs-on: macos-latest

    steps:
      - uses: actions/checkout@v4

      - name: Prepare
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p downloads extracted out

      - name: Fetch versions list (NuGet flatcontainer)
        shell: bash
        run: |
          set -euo pipefail
          ID="microsoft.ml.onnxruntime"
          URL="https://api.nuget.org/v3-flatcontainer/${ID}/index.json"
          echo "Fetch versions: $URL"
          curl -L --fail -o out/versions_macos.json "$URL"

      - name: Build verify list from input range
        shell: bash
        run: |
          set -euo pipefail

          START="${{ inputs.start_version }}"
          END="${{ inputs.end_version }}"

          ver_le() { [ "$(printf '%s\n' "$1" "$2" | sort -V | head -n1)" = "$1" ]; }
          ver_ge() { [ "$(printf '%s\n' "$1" "$2" | sort -V | tail -n1)" = "$1" ]; }

          jq -r '.versions[]' out/versions_macos.json > out/all_versions.txt

          : > out/verify_macos_list.txt
          while IFS= read -r v; do
            if ver_le "$v" "$START" && ver_ge "$v" "$END"; then
              echo "$v" >> out/verify_macos_list.txt
            fi
          done < out/all_versions.txt

          echo "Verify versions count: $(wc -l < out/verify_macos_list.txt)"
          head -n 20 out/verify_macos_list.txt || true

      - name: Download & analyze (min macOS version)
        shell: bash
        run: |
          set -euo pipefail

          PKG_ID="microsoft.ml.onnxruntime"
          echo "package,version,runtimeRid,dylib_or_so,min_macos" > out/macos_min_details.csv

          get_min_macos() {
            local f="$1"
            local min=""
            min="$(otool -l "$f" 2>/dev/null | awk '
              $1=="cmd" && $2=="LC_BUILD_VERSION" {in=1}
              in==1 && $1=="minos" {print $2; exit}
            ' || true)"
            if [[ -z "$min" ]]; then
              min="$(otool -l "$f" 2>/dev/null | awk '
                $1=="cmd" && $2=="LC_VERSION_MIN_MACOSX" {in=1}
                in==1 && $1=="version" {print $2; exit}
              ' || true)"
            fi
            [[ -z "$min" ]] && min="UNKNOWN"
            echo "$min"
          }

          while IFS= read -r ver; do
            [[ -z "$ver" ]] && continue
            echo "==== Microsoft.ML.OnnxRuntime $ver ===="

            nupkg="downloads/${PKG_ID}.${ver}.nupkg"
            url="https://api.nuget.org/v3-flatcontainer/${PKG_ID}/${ver}/${PKG_ID}.${ver}.nupkg"

            if [[ ! -f "$nupkg" ]]; then
              echo "Download: $url"
              curl -L --fail -o "$nupkg" "$url"
            else
              echo "Skip download (cached): $nupkg"
            fi

            outdir="extracted/${PKG_ID}.${ver}"
            rm -rf "$outdir"
            mkdir -p "$outdir"
            unzip -q "$nupkg" -d "$outdir"

            dylibs=()
            while IFS= read -r f; do
              [[ -z "$f" ]] && continue
              dylibs+=("$f")
            done < <(find "$outdir" -type f \( -path "*/runtimes/osx-*/native/*.dylib" -o -path "*/runtimes/osx-*/native/*.so" \) 2>/dev/null || true)

            if [[ ${#dylibs[@]} -eq 0 ]]; then
              echo "No osx native dylib/so found for $ver (skip)"
              continue
            fi

            for f in "${dylibs[@]}"; do
              rid="$(echo "$f" | sed -n 's#.*runtimes/\(osx-[^/]*\)/native/.*#\1#p')"
              base="$(basename "$f")"
              minos="$(get_min_macos "$f")"
              echo "${PKG_ID},${ver},${rid},${base},${minos}" >> out/macos_min_details.csv
            done

          done < out/verify_macos_list.txt

          echo "Wrote: out/macos_min_details.csv"
          head -n 20 out/macos_min_details.csv || true

      - name: Summarize macOS min version per package+version
        shell: bash
        run: |
          set -euo pipefail
          echo "package,version,required_min_macos" > out/macos_min_summary.csv
          tail -n +2 out/macos_min_details.csv \
            | awk -F',' 'NF>=5 {print $1","$2","$5}' \
            | sort -t',' -k1,1 -k2,2 -k3,3V \
            | awk -F',' '{k=$1","$2; last[k]=$3} END {for (k in last) print k","last[k]}' \
            | sort -t',' -k1,1 -k2,2V >> out/macos_min_summary.csv

          echo "Wrote: out/macos_min_summary.csv"
          head -n 30 out/macos_min_summary.csv || true

      - name: Upload macOS CSV
        uses: actions/upload-artifact@v4
        with:
          name: macos_min_details
          path: out/macos_min_details.csv

      - name: Upload macOS summary CSV
        uses: actions/upload-artifact@v4
        with:
          name: macos_min_summary
          path: out/macos_min_summary.csv
