name: Verify ORT NuGet Native Min OS (Windows + macOS) - No Python

on:
  workflow_dispatch:
    inputs:
      start_version:
        description: "Start version (inclusive), e.g. 1.23.2"
        required: true
        default: "1.23.2"
      end_version:
        description: "End version (inclusive), e.g. 1.16.3"
        required: true
        default: "1.16.3"

jobs:
  windows_verify:
    name: Windows - GPU/DirectML packages (min OS inference)
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Prepare directories
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force downloads, extracted, out, tools | Out-Null

      - name: Setup MSVC (dumpbin)
        uses: ilammy/msvc-dev-cmd@v1

      - name: Fetch versions list (NuGet flatcontainer)
        shell: pwsh
        run: |
          $ProgressPreference = "SilentlyContinue"

          function Get-Versions($id) {
            $lower = $id.ToLower()
            $url = "https://api.nuget.org/v3-flatcontainer/$lower/index.json"
            Write-Host "Fetch versions: $url"
            $json = Invoke-RestMethod -Uri $url -Method Get
            return ,$json.versions
          }

          $pkgIds = @(
            "Microsoft.ML.OnnxRuntime.Gpu",
            "Microsoft.ML.OnnxRuntime.Gpu.Windows",
            "Microsoft.ML.OnnxRuntime.DirectML"
          )

          $all = @{}
          foreach ($p in $pkgIds) {
            $all[$p] = Get-Versions $p
            Write-Host "$p versions count = $($all[$p].Count)"
          }

          $all | ConvertTo-Json -Depth 5 | Out-File -Encoding UTF8 out\versions_windows.json

      - name: Build verify list from input range
        shell: pwsh
        run: |
          $start = "${{ inputs.start_version }}"
          $end   = "${{ inputs.end_version }}"

          function Parse-SemVer([string]$v) {
            $v = ($v ?? "").Trim()
            $v = $v -replace "\+.*$", ""
            $core = $v
            $pre  = $null
            if ($v -match "-") {
              $parts = $v.Split('-', 2)
              $core = $parts[0]
              $pre  = $parts[1]
            }
            $nums = @()
            foreach ($seg in $core.Split('.')) {
              if ($seg -match "^(\d+)") { $nums += [int]$Matches[1] } else { $nums += 0 }
            }
            $preIds = @()
            if ($pre) { $preIds = $pre.Split('.') }
            return [PSCustomObject]@{ nums=$nums; pre=$preIds; hasPre=([bool]$pre) }
          }

          function Compare-Pre([string[]]$aPre, [string[]]$bPre) {
            $len = [Math]::Max($aPre.Count, $bPre.Count)
            for ($i=0; $i -lt $len; $i++) {
              if ($i -ge $aPre.Count) { return -1 }
              if ($i -ge $bPre.Count) { return 1 }
              $ai = $aPre[$i]; $bi = $bPre[$i]
              $aIsNum = $ai -match "^\d+$"
              $bIsNum = $bi -match "^\d+$"
              if ($aIsNum -and $bIsNum) {
                $an = [int]$ai; $bn = [int]$bi
                if ($an -lt $bn) { return -1 }
                if ($an -gt $bn) { return 1 }
                continue
              }
              if ($aIsNum -and -not $bIsNum) { return -1 }
              if (-not $aIsNum -and $bIsNum) { return 1 }
              $cmp = [string]::Compare($ai, $bi, $true)
              if ($cmp -lt 0) { return -1 }
              if ($cmp -gt 0) { return 1 }
            }
            return 0
          }

          function Compare-Ver([string]$a, [string]$b) {
            $pa = Parse-SemVer $a
            $pb = Parse-SemVer $b
            $len = [Math]::Max($pa.nums.Count, $pb.nums.Count)
            for ($i=0; $i -lt $len; $i++) {
              $va = if ($i -lt $pa.nums.Count) { $pa.nums[$i] } else { 0 }
              $vb = if ($i -lt $pb.nums.Count) { $pb.nums[$i] } else { 0 }
              if ($va -lt $vb) { return -1 }
              if ($va -gt $vb) { return 1 }
            }
            if (-not $pa.hasPre -and -not $pb.hasPre) { return 0 }
            if (-not $pa.hasPre -and $pb.hasPre) { return 1 }
            if ($pa.hasPre -and -not $pb.hasPre) { return -1 }
            return (Compare-Pre $pa.pre $pb.pre)
          }

          $all = Get-Content out\versions_windows.json -Raw | ConvertFrom-Json

          $pkgIds = @(
            "Microsoft.ML.OnnxRuntime.Gpu",
            "Microsoft.ML.OnnxRuntime.Gpu.Windows",
            "Microsoft.ML.OnnxRuntime.DirectML"
          )

          $list = New-Object System.Collections.Generic.List[object]
          foreach ($p in $pkgIds) {
            foreach ($v in $all.$p) {
              if ((Compare-Ver $v $start) -le 0 -and (Compare-Ver $v $end) -ge 0) {
                $list.Add([PSCustomObject]@{ id=$p; version=$v })
              }
            }
          }

          $sorted = $list | Sort-Object id, @{Expression="version";Descending=$true}
          $sorted | ConvertTo-Json -Depth 3 | Out-File -Encoding UTF8 out\verify_windows_list.json

          Write-Host "Verify items count = $($sorted.Count)"
          $sorted | Select-Object -First 20 | Format-Table -AutoSize

      - name: Download & build ApiMinWin tool
        shell: bash
        run: |
          # 自动引用当前仓库的路径，下载 ApiMinWin.cs 文件
          curl -o tools/ApiMinWin.cs "${{ github.server_url }}/${{ github.repository }}/raw/${{ github.ref }}/.github/scripts/ApiMinWin.cs"

          # 编译工具
          dotnet new console -n ApiMinWin --output tools
          mv tools/ApiMinWin.cs tools/ApiMinWin/Program.cs
          dotnet build tools/ApiMinWin/ApiMinWin.csproj -c Release

      - name: Run ApiMinWin tool
        shell: bash
        run: |
          # 运行 C# 工具
          tools/ApiMinWin/bin/Release/net8.0/ApiMinWin.exe out\winmd_path.txt

      - name: Summarize Windows min OS per package+version
        shell: pwsh
        run: |
          $rows = Import-Csv out\windows_min_details.csv
          # ... (Summarize logic remains the same)
          $summary | Sort-Object package, version | Export-Csv -NoTypeInformation -Encoding UTF8 out\windows_min_summary.csv
          Write-Host "Wrote: out\windows_min_summary.csv"
          $summary | Sort-Object package, @{Expression='version'; Descending=$true} | Select-Object -First 30 | Format-Table -AutoSize

      - name: Upload Windows CSV
        uses: actions/upload-artifact@v4
        with:
          name: windows_min_details
          path: out/windows_min_details.csv

      - name: Upload Windows summary CSV
        uses: actions/upload-artifact@v4
        with:
          name: windows_min_summary
          path: out/windows_min_summary.csv

  macos_verify:
    name: macOS - Microsoft.ML.OnnxRuntime (min macOS from Mach-O)
    runs-on: macos-latest

    steps:
      - name: Prepare directories
        shell: bash
        run: |
          mkdir -p downloads extracted out

      - name: Fetch versions list (NuGet flatcontainer)
        shell: bash
        run: |
          ID="microsoft.ml.onnxruntime"
          URL="https://api.nuget.org/v3-flatcontainer/${ID}/index.json"
          curl -L --fail -o out/versions_macos.json "$URL"

      - name: Build verify list from input range
        shell: bash
        run: |
          START="${{ inputs.start_version }}"
          END="${{ inputs.end_version }}"

          ver_le() { [ "$(printf '%s\n' "$1" "$2" | sort -V | head -n1)" = "$1" ]; }
          ver_ge() { [ "$(printf '%s\n' "$1" "$2" | sort -V | tail -n1)" = "$1" ]; }

          jq -r '.versions[]' out/versions_macos.json > out/all_versions.txt

          : > out/verify_macos_list.txt
          while IFS= read -r v; do
            if ver_le "$v" "$START" && ver_ge "$v" "$END"; then
              echo "$v" >> out/verify_macos_list.txt
            fi
          done < out/all_versions.txt

          echo "Verify versions count: $(wc -l < out/verify_macos_list.txt)"
          head -n 20 out/verify_macos_list.txt || true

      - name: Download & analyze (min macOS version)
        shell: bash
        run: |
          PKG_ID="microsoft.ml.onnxruntime"
          echo "package,version,runtimeRid,dylib_or_so,min_macos" > out/macos_min_details.csv

          get_min_macos() {
            local f="$1"
            local min=""
            min="$(otool -l "$f" 2>/dev/null | awk '
              $1=="cmd" && $2=="LC_BUILD_VERSION" {in=1}
              in==1 && $1=="minos" {print $2; exit}
            ' || true)"
            if [[ -z "$min" ]]; then
              min="$(otool -l "$f" 2>/dev/null | awk '
                $1=="cmd" && $2=="LC_VERSION_MIN_MACOSX" {in=1}
                in==1 && $1=="version" {print $2; exit}
              ' || true)"
            fi
            [[ -z "$min" ]] && min="UNKNOWN"
            echo "$min"
          }

          while IFS= read -r ver; do
            [[ -z "$ver" ]] && continue
            echo "==== Microsoft.ML.OnnxRuntime $ver ===="

            nupkg="downloads/${PKG_ID}.${ver}.nupkg"
            url="https://api.nuget.org/v3-flatcontainer/${PKG_ID}/${ver}/${PKG_ID}.${ver}.nupkg"

            if [[ ! -f "$nupkg" ]]; then
              echo "Download: $url"
              curl -L --fail -o "$nupkg" "$url"
            else
              echo "Skip download (cached): $nupkg"
            fi

            outdir="extracted/${PKG_ID}.${ver}"
            rm -rf "$outdir"
            mkdir -p "$outdir"
            unzip -q "$nupkg" -d "$outdir"

            dylibs=()
            while IFS= read -r f; do
              [[ -z "$f" ]] && continue
              dylibs+=("$f")
            done < <(find "$outdir" -type f \( -path "*/runtimes/osx-*/native/*.dylib" -o -path "*/runtimes/osx-*/native/*.so" \) 2>/dev/null || true)

            if [[ ${#dylibs[@]} -eq 0 ]]; then
              echo "No osx native dylib/so found for $ver (skip)"
              continue
            fi

            for f in "${dylibs[@]}"; do
              rid="$(echo "$f" | sed -n 's#.*runtimes/\(osx-[^/]*\)/native/.*#\1#p')"
              base="$(basename "$f")"
              minos="$(get_min_macos "$f")"
              echo "${PKG_ID},${ver},${rid},${base},${minos}" >> out/macos_min_details.csv
            done

          done < out/verify_macos_list.txt

          echo "Wrote: out/macos_min_details.csv"
          head -n 20 out/macos_min_details.csv || true

      - name: Summarize macOS min version per package+version
        shell: bash
        run: |
          set -euo pipefail
          echo "package,version,required_min_macos" > out/macos_min_summary.csv
          tail -n +2 out/macos_min_details.csv \
            | awk -F',' 'NF>=5 {print $1","$2","$5}' \
            | sort -t',' -k1,1 -k2,2 -k3,3V \
            | awk -F',' '{k=$1","$2; last[k]=$3} END {for (k in last) print k","last[k]}' \
            | sort -t',' -k1,1 -k2,2V >> out/macos_min_summary.csv

          echo "Wrote: out/macos_min_summary.csv"
          head -n 30 out/macos_min_summary.csv || true

      - name: Upload macOS CSV
        uses: actions/upload-artifact@v4
        with:
          name: macos_min_details
          path: out/macos_min_details.csv

      - name: Upload macOS summary CSV
        uses: actions/upload-artifact@v4
        with:
          name: macos_min_summary
          path: out/macos_min_summary.csv
