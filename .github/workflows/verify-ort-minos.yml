name: Verify ORT NuGet Native Min OS (Windows + macOS) - No Python

on:
  workflow_dispatch:
    inputs:
      start_version:
        description: "Start version (inclusive), e.g. 1.23.2"
        required: true
        default: "1.23.2"
      end_version:
        description: "End version (inclusive), e.g. 1.16.3"
        required: true
        default: "1.16.3"

jobs:
  windows_verify:
    name: Windows - GPU/DirectML packages (min OS inference)
    runs-on: windows-latest

    steps:
      - name: Prepare
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force downloads, extracted, out, tools | Out-Null

      - name: Setup MSVC (dumpbin)
        uses: ilammy/msvc-dev-cmd@v1

      - name: Fetch versions list (NuGet flatcontainer)
        shell: pwsh
        run: |
          $ProgressPreference = "SilentlyContinue"

          function Get-Versions($id) {
            $lower = $id.ToLower()
            $url = "https://api.nuget.org/v3-flatcontainer/$lower/index.json"
            Write-Host "Fetch versions: $url"
            $json = Invoke-RestMethod -Uri $url -Method Get
            return ,$json.versions
          }

          $pkgIds = @(
            "Microsoft.ML.OnnxRuntime.Gpu",
            "Microsoft.ML.OnnxRuntime.Gpu.Windows",
            "Microsoft.ML.OnnxRuntime.DirectML"
          )

          $all = @{}
          foreach ($p in $pkgIds) {
            $all[$p] = Get-Versions $p
            Write-Host "$p versions count = $($all[$p].Count)"
          }

          $all | ConvertTo-Json -Depth 5 | Out-File -Encoding UTF8 out\versions_windows.json

      - name: Build verify list from input range
        shell: pwsh
        run: |
          $start = "${{ inputs.start_version }}"
          $end   = "${{ inputs.end_version }}"

          function Parse-SemVer([string]$v) {
            $v = ($v ?? "").Trim()
            $v = $v -replace "\+.*$", ""
            $core = $v
            $pre  = $null
            if ($v -match "-") {
              $parts = $v.Split('-', 2)
              $core = $parts[0]
              $pre  = $parts[1]
            }
            $nums = @()
            foreach ($seg in $core.Split('.')) {
              if ($seg -match "^(\d+)") { $nums += [int]$Matches[1] } else { $nums += 0 }
            }
            $preIds = @()
            if ($pre) { $preIds = $pre.Split('.') }
            return [PSCustomObject]@{ nums=$nums; pre=$preIds; hasPre=([bool]$pre) }
          }

          function Compare-Pre([string[]]$aPre, [string[]]$bPre) {
            $len = [Math]::Max($aPre.Count, $bPre.Count)
            for ($i=0; $i -lt $len; $i++) {
              if ($i -ge $aPre.Count) { return -1 }
              if ($i -ge $bPre.Count) { return 1 }
              $ai = $aPre[$i]; $bi = $bPre[$i]
              $aIsNum = $ai -match "^\d+$"
              $bIsNum = $bi -match "^\d+$"
              if ($aIsNum -and $bIsNum) {
                $an = [int]$ai; $bn = [int]$bi
                if ($an -lt $bn) { return -1 }
                if ($an -gt $bn) { return 1 }
                continue
              }
              if ($aIsNum -and -not $bIsNum) { return -1 }
              if (-not $aIsNum -and $bIsNum) { return 1 }
              $cmp = [string]::Compare($ai, $bi, $true)
              if ($cmp -lt 0) { return -1 }
              if ($cmp -gt 0) { return 1 }
            }
            return 0
          }

          function Compare-Ver([string]$a, [string]$b) {
            $pa = Parse-SemVer $a
            $pb = Parse-SemVer $b
            $len = [Math]::Max($pa.nums.Count, $pb.nums.Count)
            for ($i=0; $i -lt $len; $i++) {
              $va = if ($i -lt $pa.nums.Count) { $pa.nums[$i] } else { 0 }
              $vb = if ($i -lt $pb.nums.Count) { $pb.nums[$i] } else { 0 }
              if ($va -lt $vb) { return -1 }
              if ($va -gt $vb) { return 1 }
            }
            if (-not $pa.hasPre -and -not $pb.hasPre) { return 0 }
            if (-not $pa.hasPre -and $pb.hasPre) { return 1 }
            if ($pa.hasPre -and -not $pb.hasPre) { return -1 }
            return (Compare-Pre $pa.pre $pb.pre)
          }

          $all = Get-Content out\versions_windows.json -Raw | ConvertFrom-Json

          $pkgIds = @(
            "Microsoft.ML.OnnxRuntime.Gpu",
            "Microsoft.ML.OnnxRuntime.Gpu.Windows",
            "Microsoft.ML.OnnxRuntime.DirectML"
          )

          $list = New-Object System.Collections.Generic.List[object]
          foreach ($p in $pkgIds) {
            foreach ($v in $all.$p) {
              if ((Compare-Ver $v $start) -le 0 -and (Compare-Ver $v $end) -ge 0) {
                $list.Add([PSCustomObject]@{ id=$p; version=$v })
              }
            }
          }

          $sorted = $list | Sort-Object id, @{Expression="version";Descending=$true}
          $sorted | ConvertTo-Json -Depth 3 | Out-File -Encoding UTF8 out\verify_windows_list.json

          Write-Host "Verify items count = $($sorted.Count)"
          $sorted | Select-Object -First 20 | Format-Table -AutoSize

      - name: Download Win32 metadata (Microsoft.Windows.SDK.NET) and build API mapper tool
        shell: pwsh
        run: |
          $ProgressPreference = "SilentlyContinue"

          # 1) 找到 Microsoft.Windows.SDK.NET 最新稳定版（排除 preview）
          $id = "microsoft.windows.sdk.net"
          $indexUrl = "https://api.nuget.org/v3-flatcontainer/$id/index.json"
          Write-Host "Fetch: $indexUrl"
          $vers = (Invoke-RestMethod -Uri $indexUrl -Method Get).versions
          $stable = $vers | Where-Object { $_ -notmatch "-" }
          $ver = $stable[-1]
          Write-Host "Use Microsoft.Windows.SDK.NET version = $ver"

          # 2) 下载 nupkg 并解压
          $nupkg = "downloads\$id.$ver.nupkg"
          $pkgUrl = "https://api.nuget.org/v3-flatcontainer/$id/$ver/$id.$ver.nupkg"
          Write-Host "Download: $pkgUrl"
          Invoke-WebRequest -Uri $pkgUrl -OutFile $nupkg

          $sdkDir = "tools\sdknet.$ver"
          if (Test-Path $sdkDir) { Remove-Item $sdkDir -Recurse -Force }
          New-Item -ItemType Directory -Force $sdkDir | Out-Null
          Expand-Archive -Path $nupkg -DestinationPath $sdkDir -Force

          # 3) 找到 Windows.Win32.winmd
          $winmd = Get-ChildItem -Path $sdkDir -Recurse -Filter "Windows.Win32.winmd" -File | Select-Object -First 1
          if (-not $winmd) { throw "Windows.Win32.winmd not found in Microsoft.Windows.SDK.NET package" }
          Write-Host "Found winmd: $($winmd.FullName)"

          # 4) 写一个小 C# 工具：读取 winmd，构建 (dll!entrypoint)->minBuild 映射，然后吃 stdin 的 imports 输出结果
          $toolDir = "tools\ApiMinWin"
          if (Test-Path $toolDir) { Remove-Item $toolDir -Recurse -Force }
          New-Item -ItemType Directory -Force $toolDir | Out-Null

          @"
<Project Sdk='Microsoft.NET.Sdk'>
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
</Project>
"@ | Out-File -Encoding UTF8 "$toolDir\ApiMinWin.csproj"

          @"
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection.Metadata;
using System.Reflection.PortableExecutable;

static class Program
{
  static int Main(string[] args)
  {
    if (args.Length < 1)
    {
      Console.Error.WriteLine("Usage: ApiMinWin <path-to-Windows.Win32.winmd>");
      return 2;
    }

    var winmdPath = args[0];
    if (!File.Exists(winmdPath))
    {
      Console.Error.WriteLine("winmd not found: " + winmdPath);
      return 2;
    }

    // Build map: "kernel32.dll!SetThreadDescription" -> (minBuild, reasonString)
    var map = BuildMap(winmdPath);
    Console.Error.WriteLine($"[ApiMinWin] map size = {map.Count}");

    // stdin: lines "dll,func"
    // stdout: "dll,func,minBuild,reason"
    Console.WriteLine("dll,func,minBuild,reason");
    string? line;
    while ((line = Console.ReadLine()) != null)
    {
      line = line.Trim();
      if (line.Length == 0) continue;
      var parts = line.Split(',', 2);
      if (parts.Length < 2) continue;
      var dll = parts[0].Trim().ToLowerInvariant();
      var func = parts[1].Trim();

      var key = dll + "!" + func;
      if (map.TryGetValue(key, out var v))
      {
        Console.WriteLine($"{dll},{Escape(func)},{v.minBuild},{Escape(v.reason)}");
      }
      else
      {
        // Try common normalization: strip A/W suffix sometimes mismatched
        var alt = TryAltKeys(dll, func);
        if (alt != null && map.TryGetValue(alt, out v))
        {
          Console.WriteLine($"{dll},{Escape(func)},{v.minBuild},{Escape(v.reason)}");
        }
        else
        {
          Console.WriteLine($"{dll},{Escape(func)},,");
        }
      }
    }
    return 0;
  }

  static string Escape(string s)
  {
    if (s.Contains(',') || s.Contains('\"'))
      return "\"" + s.Replace("\"", "\"\"") + "\"";
    return s;
  }

  static string? TryAltKeys(string dll, string func)
  {
    // Some APIs have A/W variants; if import is e.g. CreateFileW but metadata entrypoint is CreateFileW (usually same).
    // Keep a tiny helper: if endswith A/W, also try without suffix.
    if (func.Length > 1)
    {
      char last = func[^1];
      if (last == 'A' || last == 'W')
      {
        return dll + "!" + func.Substring(0, func.Length - 1);
      }
    }
    return null;
  }

  static Dictionary<string,(int minBuild,string reason)> BuildMap(string winmdPath)
  {
    using var fs = File.OpenRead(winmdPath);
    using var pe = new PEReader(fs);
    var md = pe.GetMetadataReader();

    // Need handles to attribute types we care about
    var dllImportType = "System.Runtime.InteropServices.DllImportAttribute";
    var supportedType = "System.Runtime.Versioning.SupportedOSPlatformAttribute";

    var map = new Dictionary<string,(int,string)>(StringComparer.OrdinalIgnoreCase);

    foreach (var typeHandle in md.TypeDefinitions)
    {
      var type = md.GetTypeDefinition(typeHandle);

      foreach (var methodHandle in type.GetMethods())
      {
        var method = md.GetMethodDefinition(methodHandle);

        string? dllName = null;
        string? entryPoint = null;
        int minBuild = 0;
        string? minReason = null;

        foreach (var caHandle in method.GetCustomAttributes())
        {
          var ca = md.GetCustomAttribute(caHandle);
          var attrName = GetAttributeTypeFullName(md, ca);
          if (attrName == null) continue;

          if (attrName == dllImportType)
          {
            // DllImport(string dllName) + named arg EntryPoint?
            ReadDllImport(md, ca, out dllName, out entryPoint);
          }
          else if (attrName == supportedType)
          {
            var plat = ReadSingleStringCtorArg(md, ca);
            if (plat != null)
            {
              // examples: "windows10.0.17763.0", "windows6.1" etc
              var build = ExtractBuild(plat);
              if (build > minBuild)
              {
                minBuild = build;
                minReason = plat;
              }
            }
          }
        }

        if (dllName == null) continue;

        var dllLower = dllName.Trim().ToLowerInvariant();
        var ep = entryPoint ?? md.GetString(method.Name);
        if (string.IsNullOrWhiteSpace(ep)) continue;

        // If no supported attribute, minBuild stays 0 -> we still store it but blank meaning "no info"
        var key = dllLower + "!" + ep;
        if (!map.TryGetValue(key, out var existing) || minBuild > existing.minBuild)
        {
          var reason = minReason ?? "";
          map[key] = (minBuild, reason);
        }
      }
    }

    // Remove items with build=0? Keep them; caller will treat as unknown.
    return map;
  }

  static int ExtractBuild(string s)
  {
    // windows10.0.17763.0 => 17763
    // windows11.0.22000.0 => 22000
    // windows8.1 => unknown build => 0
    var parts = s.Split('.', StringSplitOptions.RemoveEmptyEntries);
    // find a numeric token >= 10000
    foreach (var p in parts)
    {
      if (int.TryParse(p, out int v) && v >= 10000) return v;
    }
    return 0;
  }

  static string? ReadSingleStringCtorArg(MetadataReader md, CustomAttribute ca)
  {
    var value = ca.Value;
    var blob = md.GetBlobReader(value);
    // Prolog 0x0001
    if (blob.ReadUInt16() != 1) return null;
    return blob.ReadSerializedString();
  }

  static void ReadDllImport(MetadataReader md, CustomAttribute ca, out string? dllName, out string? entryPoint)
  {
    dllName = null;
    entryPoint = null;

    var blob = md.GetBlobReader(ca.Value);
    if (blob.ReadUInt16() != 1) return;

    // ctor args: string dllName
    dllName = blob.ReadSerializedString();

    // named args
    if (blob.Offset >= blob.Length) return;
    ushort numNamed = blob.ReadUInt16();
    for (int i = 0; i < numNamed; i++)
    {
      byte kind = blob.ReadByte(); // 0x53 field, 0x54 property
      byte type = blob.ReadByte(); // element type
      string? name = blob.ReadSerializedString();
      object? val = ReadFixedArg(md, ref blob, type);
      if (name != null && name.Equals("EntryPoint", StringComparison.OrdinalIgnoreCase))
      {
        entryPoint = val as string;
      }
    }
  }

  static object? ReadFixedArg(MetadataReader md, ref BlobReader blob, byte et)
  {
    // minimal support: string only (0x0E)
    if (et == 0x0E)
    {
      return blob.ReadSerializedString();
    }
    // fall back: skip unsupported
    // Some named args might be other primitives; ignore safely.
    SkipFixedArg(ref blob, et);
    return null;
  }

  static void SkipFixedArg(ref BlobReader blob, byte et)
  {
    // primitive types sizes; this is best-effort skip
    switch (et)
    {
      case 0x02: blob.ReadBoolean(); break;
      case 0x03: blob.ReadByte(); break;
      case 0x04: blob.ReadSByte(); break;
      case 0x05: blob.ReadInt16(); break;
      case 0x06: blob.ReadUInt16(); break;
      case 0x07: blob.ReadInt32(); break;
      case 0x08: blob.ReadUInt32(); break;
      case 0x09: blob.ReadInt64(); break;
      case 0x0A: blob.ReadUInt64(); break;
      case 0x0B: blob.ReadSingle(); break;
      case 0x0C: blob.ReadDouble(); break;
      case 0x0E: blob.ReadSerializedString(); break;
      default:
        // unknown -> give up
        break;
    }
  }

  static string? GetAttributeTypeFullName(MetadataReader md, CustomAttribute ca)
  {
    EntityHandle ctor = ca.Constructor;
    StringHandle nameHandle;
    StringHandle nsHandle;

    if (ctor.Kind == HandleKind.MemberReference)
    {
      var mr = md.GetMemberReference((MemberReferenceHandle)ctor);
      var parent = mr.Parent;
      if (parent.Kind == HandleKind.TypeReference)
      {
        var tr = md.GetTypeReference((TypeReferenceHandle)parent);
        nameHandle = tr.Name;
        nsHandle = tr.Namespace;
      }
      else if (parent.Kind == HandleKind.TypeDefinition)
      {
        var td = md.GetTypeDefinition((TypeDefinitionHandle)parent);
        nameHandle = td.Name;
        nsHandle = td.Namespace;
      }
      else return null;
    }
    else if (ctor.Kind == HandleKind.MethodDefinition)
    {
      var mdh = md.GetMethodDefinition((MethodDefinitionHandle)ctor);
      var td = md.GetTypeDefinition(mdh.GetDeclaringType());
      nameHandle = td.Name;
      nsHandle = td.Namespace;
    }
    else return null;

    var name = md.GetString(nameHandle);
    var ns = md.GetString(nsHandle);
    if (string.IsNullOrEmpty(ns)) return name;
    return ns + "." + name;
  }
}
"@ | Out-File -Encoding UTF8 "$toolDir\Program.cs"

          Write-Host "Build ApiMinWin tool..."
          dotnet build "$toolDir\ApiMinWin.csproj" -c Release

          # 5) 记录 winmd 路径给后续步骤使用
          "$($winmd.FullName)" | Out-File -Encoding UTF8 "out\win32_winmd_path.txt"
          Write-Host "Saved winmd path to out\win32_winmd_path.txt"

      - name: Download & analyze packages (PE headers + Win32 metadata API min build)
        shell: pwsh
        run: |
          $ProgressPreference = "SilentlyContinue"
          $items = Get-Content out\verify_windows_list.json -Raw | ConvertFrom-Json

          $winmdPath = (Get-Content out\win32_winmd_path.txt -Raw).Trim()
          if (-not (Test-Path $winmdPath)) { throw "winmd path invalid: $winmdPath" }

          $toolExe = "tools\ApiMinWin\bin\Release\net8.0\ApiMinWin.exe"
          if (-not (Test-Path $toolExe)) { throw "tool not built: $toolExe" }

          $csv = New-Object System.Collections.Generic.List[string]
          $csv.Add("package,version,runtimeRid,dll,pe_MinOS,pe_Subsystem,pe_SubsystemVer,imports_MinWinGuess,api_MinWinBuild,api_MinWinReason")

          function Get-PeHeaderInfo([string]$dllPath) {
            $hdr = (dumpbin /nologo /headers $dllPath) 2>&1
            $minos = ""
            $subsys = ""
            $subver = ""
            foreach ($line in $hdr) {
              if ($line -match "^\s*([0-9]+)\.([0-9]+)\s+operating system version") {
                $minos = "$($Matches[1]).$($Matches[2])"
              }
              if ($line -match "^\s*([0-9]+)\.([0-9]+)\s+subsystem version") {
                $subver = "$($Matches[1]).$($Matches[2])"
              }
              if ($line -match "^\s*Subsystem\s+(.+)$") {
                $subsys = $Matches[1].Trim()
              }
            }
            return @{ MinOS=$minos; Subsystem=$subsys; SubsystemVer=$subver }
          }

          function Get-ImportsPairs([string]$dllPath) {
            # Parse dumpbin /imports output into "dll,func" lines
            $out = (dumpbin /nologo /imports $dllPath) 2>&1
            $pairs = New-Object System.Collections.Generic.List[string]
            $curDll = $null

            foreach ($line in $out) {
              # Example: "    KERNEL32.dll"
              if ($line -match "^\s*([A-Za-z0-9\-\._]+\.dll)\s*$") {
                $curDll = $Matches[1].ToLower()
                continue
              }
              if ($curDll) {
                # Typical import line contains function name at end; examples vary:
                # "             3F0   SetThreadDescription"
                # "            12A0   GetProcAddress"
                if ($line -match "^\s*[0-9A-Fa-f]+\s+[0-9A-Fa-f]+\s+([A-Za-z0-9_\?\@\$\.\#]+)\s*$" -or
                    $line -match "^\s*[0-9A-Fa-f]+\s+([A-Za-z0-9_\?\@\$\.\#]+)\s*$") {
                  $fn = $Matches[1]
                  # 过滤掉无意义的符号
                  if ($fn -and $fn -ne "NULL") {
                    $pairs.Add("$curDll,$fn")
                  }
                }
              }
            }
            return $pairs
          }

          function Compute-MinBuildFromImports([string]$dllPath) {
            $pairs = Get-ImportsPairs $dllPath
            if ($pairs.Count -eq 0) {
              return @{ build=""; reason="" }
            }

            $tmp = Join-Path $env:RUNNER_TEMP ("imports_" + [Guid]::NewGuid().ToString("N") + ".txt")
            $pairs | Out-File -Encoding UTF8 $tmp

            # Run tool, capture CSV output
            $res = & $toolExe $winmdPath < $tmp
            Remove-Item $tmp -Force -ErrorAction SilentlyContinue

            # Parse tool output, find max build
            $maxBuild = 0
            $maxReason = ""
            $lines = $res -split "`r?`n" | Where-Object { $_ -and $_.Trim().Length -gt 0 }
            foreach ($ln in $lines | Select-Object -Skip 1) {
              # dll,func,minBuild,reason
              $cols = $ln.Split(',', 4)
              if ($cols.Length -ge 3) {
                $b = $cols[2].Trim()
                if ($b -match "^\d+$") {
                  $bi = [int]$b
                  if ($bi -gt $maxBuild) {
                    $maxBuild = $bi
                    $maxReason = if ($cols.Length -ge 4) { $cols[3].Trim().Trim('"') } else { "" }
                    # 同时把函数名也带上
                    $fn = $cols[1].Trim().Trim('"')
                    $dll = $cols[0].Trim().Trim('"')
                    $maxReason = "$dll!$fn -> $maxReason"
                  }
                }
              }
            }

            if ($maxBuild -gt 0) {
              return @{ build="$maxBuild"; reason=$maxReason }
            }
            return @{ build=""; reason="" }
          }

          function Fallback-Guess([string]$importsText) {
            # 作为兜底（少数情况 winmd 没覆盖/解析失败）
            if ($importsText -match "(?i)\bCoRevokeDeviceCatalog\b") { return "Win10 2004 (19041)+ (fallback sentinel)" }
            if ($importsText -match "(?i)\bIsWindowArranged\b") { return "Win10 1903 (18362)+ (fallback sentinel)" }
            if ($importsText -match "(?i)\bDestroySyntheticPointerDevice\b") { return "Win10 1809 (17763)+ (fallback sentinel)" }
            if ($importsText -match "(?i)\bSetUserGeoName\b") { return "Win10 1709 (16299)+ (fallback sentinel)" }
            return "Unknown (no metadata hit; maybe dynamic load or uncommon APIs)"
          }

          foreach ($it in $items) {
            $id = $it.id
            $ver = $it.version
            $lower = $id.ToLower()

            Write-Host "==== $id $ver ===="

            $nupkg = "downloads\$lower.$ver.nupkg"
            $url   = "https://api.nuget.org/v3-flatcontainer/$lower/$ver/$lower.$ver.nupkg"

            if (-not (Test-Path $nupkg)) {
              Write-Host "Download: $url"
              Invoke-WebRequest -Uri $url -OutFile $nupkg
            } else {
              Write-Host "Skip download (cached): $nupkg"
            }

            $outdir = "extracted\$lower.$ver"
            if (Test-Path $outdir) { Remove-Item $outdir -Recurse -Force }
            New-Item -ItemType Directory -Force $outdir | Out-Null
            Expand-Archive -Path $nupkg -DestinationPath $outdir -Force

            $nativeDirs = Get-ChildItem -Path $outdir -Recurse -Directory |
              Where-Object { $_.FullName -match "runtimes\\win-(x86|x64|arm64)\\native$" }

            foreach ($nd in $nativeDirs) {
              $rid = ($nd.FullName -replace '.*runtimes\\', '' -replace '\\native$', '')
              $dlls = Get-ChildItem -Path $nd.FullName -Filter *.dll -File

              foreach ($d in $dlls) {
                $pe = Get-PeHeaderInfo $d.FullName

                # Win32 metadata 推断 build
                $meta = Compute-MinBuildFromImports $d.FullName

                # 兜底：原始 imports 哨兵
                $importsText = (dumpbin /nologo /imports $d.FullName) 2>&1 -join "`n"
                $guess = if ($meta.build) {
                  "Win10+ build $($meta.build) (by Win32 metadata)"
                } else {
                  Fallback-Guess $importsText
                }

                Write-Host "  [$rid] $($d.Name)"
                Write-Host "    pe_MinOS=$($pe.MinOS) pe_SubsystemVer=$($pe.SubsystemVer)"
                Write-Host "    api_MinWinBuild=$($meta.build)"
                Write-Host "    api_MinWinReason=$($meta.reason)"
                Write-Host "    imports_MinWinGuess=$guess"

                $csv.Add(("{0},{1},{2},{3},{4},{5},{6},{7},{8},{9}" -f `
                  $id, $ver, $rid, $d.Name, $pe.MinOS, ($pe.Subsystem -replace ',', ' '), $pe.SubsystemVer, `
                  ($guess -replace ',', ' '), $meta.build, ($meta.reason -replace ',', ' ')))
              }
            }
          }

          $csv | Out-File -Encoding UTF8 out\windows_min_details.csv
          Write-Host "Wrote: out\windows_min_details.csv"

      - name: Summarize Windows min OS per package+version
        shell: pwsh
        run: |
          $rows = Import-Csv out\windows_min_details.csv

          function Parse-MajorMinor([string]$s) {
            if ([string]::IsNullOrWhiteSpace($s)) { return $null }
            if ($s -match "^(\d+)\.(\d+)") {
              return [PSCustomObject]@{ Major=[int]$Matches[1]; Minor=[int]$Matches[2] }
            }
            return $null
          }

          function Cmp-MajorMinor($a, $b) {
            if ($null -eq $a -and $null -eq $b) { return 0 }
            if ($null -eq $a) { return -1 }
            if ($null -eq $b) { return 1 }
            if ($a.Major -ne $b.Major) { return [Math]::Sign($a.Major - $b.Major) }
            return [Math]::Sign($a.Minor - $b.Minor)
          }

          function Max-MajorMinor($vals) {
            $max = $null
            foreach ($v in $vals) {
              if (Cmp-MajorMinor $v $max -gt 0) { $max = $v }
            }
            return $max
          }

          $summary = $rows |
            Group-Object package,version |
            ForEach-Object {
              $grp = $_.Group
              $peMin = Max-MajorMinor ($grp | ForEach-Object { Parse-MajorMinor $_.pe_MinOS })
              $subMin = Max-MajorMinor ($grp | ForEach-Object { Parse-MajorMinor $_.pe_SubsystemVer })

              $maxApiBuild = ($grp | ForEach-Object {
                if ($_.api_MinWinBuild -match "^\d+$") { [int]$_.api_MinWinBuild } else { 0 }
              } | Measure-Object -Maximum).Maximum

              $bestReason = ($grp | Where-Object { $_.api_MinWinBuild -eq "$maxApiBuild" } | Select-Object -First 1).api_MinWinReason

              $peStr  = if ($peMin) { "{0}.{1}" -f $peMin.Major, $peMin.Minor } else { "UNKNOWN" }
              $subStr = if ($subMin) { "{0}.{1}" -f $subMin.Major, $subMin.Minor } else { "UNKNOWN" }

              [PSCustomObject]@{
                package = $grp[0].package
                version = $grp[0].version
                required_pe_MinOS = $peStr
                required_pe_SubsystemVer = $subStr
                api_based_min_win_build = if ($maxApiBuild -gt 0) { $maxApiBuild } else { "UNKNOWN" }
                api_based_reason = $bestReason
              }
            }

          $summary | Sort-Object package, version | Export-Csv -NoTypeInformation -Encoding UTF8 out\windows_min_summary.csv
          Write-Host "Wrote: out\windows_min_summary.csv"
          $summary | Sort-Object package, @{Expression='version'; Descending=$true} | Select-Object -First 30 | Format-Table -AutoSize

      - name: Upload Windows CSV
        uses: actions/upload-artifact@v4
        with:
          name: windows_min_details
          path: out/windows_min_details.csv

      - name: Upload Windows summary CSV
        uses: actions/upload-artifact@v4
        with:
          name: windows_min_summary
          path: out/windows_min_summary.csv

  macos_verify:
    name: macOS - Microsoft.ML.OnnxRuntime (min macOS from Mach-O)
    runs-on: macos-latest

    steps:
      - name: Prepare
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p downloads extracted out

      - name: Fetch versions list (NuGet flatcontainer)
        shell: bash
        run: |
          set -euo pipefail
          ID="microsoft.ml.onnxruntime"
          URL="https://api.nuget.org/v3-flatcontainer/${ID}/index.json"
          echo "Fetch versions: $URL"
          curl -L --fail -o out/versions_macos.json "$URL"

      - name: Build verify list from input range
        shell: bash
        run: |
          set -euo pipefail

          START="${{ inputs.start_version }}"
          END="${{ inputs.end_version }}"

          ver_le() { [ "$(printf '%s\n' "$1" "$2" | sort -V | head -n1)" = "$1" ]; }
          ver_ge() { [ "$(printf '%s\n' "$1" "$2" | sort -V | tail -n1)" = "$1" ]; }

          jq -r '.versions[]' out/versions_macos.json > out/all_versions.txt

          : > out/verify_macos_list.txt
          while IFS= read -r v; do
            if ver_le "$v" "$START" && ver_ge "$v" "$END"; then
              echo "$v" >> out/verify_macos_list.txt
            fi
          done < out/all_versions.txt

          echo "Verify versions count: $(wc -l < out/verify_macos_list.txt)"
          head -n 20 out/verify_macos_list.txt || true

      - name: Download & analyze (min macOS version)
        shell: bash
        run: |
          set -euo pipefail

          PKG_ID="microsoft.ml.onnxruntime"
          echo "package,version,runtimeRid,dylib_or_so,min_macos" > out/macos_min_details.csv

          get_min_macos() {
            local f="$1"
            local min=""
            min="$(otool -l "$f" 2>/dev/null | awk '
              $1=="cmd" && $2=="LC_BUILD_VERSION" {in=1}
              in==1 && $1=="minos" {print $2; exit}
            ' || true)"
            if [[ -z "$min" ]]; then
              min="$(otool -l "$f" 2>/dev/null | awk '
                $1=="cmd" && $2=="LC_VERSION_MIN_MACOSX" {in=1}
                in==1 && $1=="version" {print $2; exit}
              ' || true)"
            fi
            [[ -z "$min" ]] && min="UNKNOWN"
            echo "$min"
          }

          while IFS= read -r ver; do
            [[ -z "$ver" ]] && continue
            echo "==== Microsoft.ML.OnnxRuntime $ver ===="

            nupkg="downloads/${PKG_ID}.${ver}.nupkg"
            url="https://api.nuget.org/v3-flatcontainer/${PKG_ID}/${ver}/${PKG_ID}.${ver}.nupkg"

            if [[ ! -f "$nupkg" ]]; then
              echo "Download: $url"
              curl -L --fail -o "$nupkg" "$url"
            else
              echo "Skip download (cached): $nupkg"
            fi

            outdir="extracted/${PKG_ID}.${ver}"
            rm -rf "$outdir"
            mkdir -p "$outdir"
            unzip -q "$nupkg" -d "$outdir"

            dylibs=()
            while IFS= read -r f; do
              [[ -z "$f" ]] && continue
              dylibs+=("$f")
            done < <(find "$outdir" -type f \( -path "*/runtimes/osx-*/native/*.dylib" -o -path "*/runtimes/osx-*/native/*.so" \) 2>/dev/null || true)

            if [[ ${#dylibs[@]} -eq 0 ]]; then
              echo "No osx native dylib/so found for $ver (skip)"
              continue
            fi

            for f in "${dylibs[@]}"; do
              rid="$(echo "$f" | sed -n 's#.*runtimes/\(osx-[^/]*\)/native/.*#\1#p')"
              base="$(basename "$f")"
              minos="$(get_min_macos "$f")"
              echo "${PKG_ID},${ver},${rid},${base},${minos}" >> out/macos_min_details.csv
            done

          done < out/verify_macos_list.txt

          echo "Wrote: out/macos_min_details.csv"
          head -n 20 out/macos_min_details.csv || true

      - name: Summarize macOS min version per package+version
        shell: bash
        run: |
          set -euo pipefail
          echo "package,version,required_min_macos" > out/macos_min_summary.csv
          tail -n +2 out/macos_min_details.csv \
            | awk -F',' 'NF>=5 {print $1","$2","$5}' \
            | sort -t',' -k1,1 -k2,2 -k3,3V \
            | awk -F',' '{k=$1","$2; last[k]=$3} END {for (k in last) print k","last[k]}' \
            | sort -t',' -k1,1 -k2,2V >> out/macos_min_summary.csv

          echo "Wrote: out/macos_min_summary.csv"
          head -n 30 out/macos_min_summary.csv || true

      - name: Upload macOS CSV
        uses: actions/upload-artifact@v4
        with:
          name: macos_min_details
          path: out/macos_min_details.csv

      - name: Upload macOS summary CSV
        uses: actions/upload-artifact@v4
        with:
          name: macos_min_summary
          path: out/macos_min_summary.csv
