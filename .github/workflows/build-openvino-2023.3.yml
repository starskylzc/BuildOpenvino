name: Extract OpenVINO Minimal Runtime (Windows CPU+GPU, macOS CPU, ONNX)

on:
  workflow_dispatch:

jobs:
  extract:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            platform: windows
            url: https://storage.openvinotoolkit.org/repositories/openvino/packages/2023.3/windows/w_openvino_toolkit_windows_2023.3.0.13775.ceeafaf64f3_x86_64.zip
            archive: openvino_win.zip
          - os: macos-latest
            platform: macos
            url: https://storage.openvinotoolkit.org/repositories/openvino/packages/2023.3/macos/m_openvino_toolkit_macos_10_15_2023.3.0.13775.ceeafaf64f3_x86_64.tgz
            archive: openvino_mac.tgz

    runs-on: ${{ matrix.os }}

    steps:
      - uses: actions/checkout@v4

      - name: Download
        shell: bash
        run: |
          set -euxo pipefail
          curl -L --retry 5 --retry-delay 2 -o "${{ matrix.archive }}" "${{ matrix.url }}"
          ls -lh "${{ matrix.archive }}"

      - name: Extract
        shell: bash
        run: |
          set -euxo pipefail
          rm -rf _src && mkdir -p _src

          if [[ "${{ matrix.platform }}" == "windows" ]]; then
            # Windows 解压
            if (Test-Path openvino_win.zip) {
              Expand-Archive -Path openvino_win.zip -DestinationPath _src
            } else {
              tar -xf openvino_win.zip -C _src
            }
          else
            # macOS 和其他 Linux 环境解压
            tar -xzf "${{ matrix.archive }}" -C _src
          fi

          echo "=== _src top ==="
          ls -la _src
          echo "=== dirs depth<=3 ==="
          find _src -maxdepth 3 -type d -print

      # ------------------------------------------------------------
      # Windows x64: Intel GPU + Intel CPU + ONNX frontend + TBB
      # Seeds: openvino + openvino_c + plugins.xml + TBB deps
      #       + openvino_intel_gpu_plugin + openvino_intel_cpu_plugin
      #       + openvino_onnx_frontend
      # Then: dumpbin dependency closure, only copy deps found INSIDE Release folder
      # Also: rewrite plugins.xml => CPU+GPU, location relative to openvino.dll directory
      # ------------------------------------------------------------
      - name: Extract minimal runtime (Windows, CPU + GPU + ONNX, exact seeds + closure + TBB)
        if: matrix.platform == 'windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          Write-Host "=== Locate runtime root ==="
          $runtimeDir = Get-ChildItem -Path "_src" -Recurse -Directory -Filter "runtime" | Select-Object -First 1
          if (-not $runtimeDir) { throw "Cannot find runtime directory under _src" }
          $runtimeDir = $runtimeDir.FullName
          Write-Host "runtimeDir = $runtimeDir"

          $binRel = Join-Path $runtimeDir "bin\intel64\Release"
          if (-not (Test-Path $binRel)) { throw "Cannot find: $binRel" }
          Write-Host "binRel = $binRel"
          Get-ChildItem $binRel | Sort-Object Name | Format-Table Name,Length

          # C API header
          $ieHeader = Join-Path $runtimeDir "include\ie\c_api\ie_c_api.h"
          if (-not (Test-Path $ieHeader)) { throw "Missing header: $ieHeader" }

          # plugins.xml (search)
          $pluginsXml = Join-Path $binRel "plugins.xml"
          if (-not (Test-Path $pluginsXml)) {
            $pluginsXml = Get-ChildItem -Path $runtimeDir -Recurse -File -Filter "plugins.xml" | Select-Object -First 1 | ForEach-Object { $_.FullName }
          }
          if (-not $pluginsXml -or -not (Test-Path $pluginsXml)) { throw "plugins.xml not found" }
          Write-Host "plugins.xml = $pluginsXml"

          # cache.json (GPU support file per docs)
          $cacheJson = Join-Path $binRel "cache.json"
          if (-not (Test-Path $cacheJson)) { throw "cache.json not found in Release folder: $binRel" }

          # Locate dumpbin.exe
          $vswhere = Join-Path ${env:ProgramFiles(x86)} "Microsoft Visual Studio\Installer\vswhere.exe"
          if (-not (Test-Path $vswhere)) { throw "vswhere not found: $vswhere" }
          $dumpbin = & $vswhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -find **\dumpbin.exe | Select-Object -First 1
          if (-not $dumpbin -or -not (Test-Path $dumpbin)) { throw "dumpbin.exe not found" }
          Write-Host "dumpbin = $dumpbin"

          function Get-DllDependents([string]$filePath) {
            $out = & $dumpbin /nologo /dependents $filePath 2>$null
            if (-not $out) { return @() }
            $deps = @()
            foreach ($line in $out) {
              $t = $line.Trim()
              if ($t -match '^[A-Za-z0-9\-\._]+\.dll$') { $deps += $t }
            }
            return $deps | Select-Object -Unique
          }

          function IsSystemImport([string]$dllName) {
            $n = $dllName.ToLowerInvariant()
            if ($n.StartsWith("api-ms-win-") -or $n.StartsWith("ext-ms-win-")) { return $true }
            if ($n -in @(
              "kernel32.dll","user32.dll","gdi32.dll","advapi32.dll","ole32.dll","oleaut32.dll",
              "shell32.dll","shlwapi.dll","winmm.dll","ws2_32.dll","ntdll.dll","comdlg32.dll",
              "secur32.dll","bcrypt.dll","crypt32.dll","dbghelp.dll","psapi.dll","iphlpapi.dll",
              "version.dll","msvcrt.dll","ucrtbase.dll",
              # GPU plugin OS dep is OpenCL.dll (system)
              "opencl.dll"
            )) { return $true }
            return $false
          }

          # Output: everything in ONE folder to guarantee program-dir loading
          $outRoot = Join-Path (Resolve-Path ".") "dist\openvino-min-windows"
          $outBin  = Join-Path $outRoot "bin"
          $outInc  = Join-Path $outRoot "include\ie\c_api"
          New-Item -ItemType Directory -Force -Path $outBin | Out-Null
          New-Item -ItemType Directory -Force -Path $outInc | Out-Null

          # Exact seeds for your scenario (ONNX + CPU + GPU + C API)
          # per docs: openvino, openvino_c, plugins.xml, device plugin, ONNX frontend, GPU cache.json
          $seedNames = @(
            "openvino.dll",
            "openvino_c.dll",
            "openvino_intel_gpu_plugin.dll",
            "openvino_intel_cpu_plugin.dll",
            "openvino_onnx_frontend.dll"
          )

          $seedPaths = @()
          foreach ($n in $seedNames) {
            $p = Join-Path $binRel $n
            if (-not (Test-Path $p)) { throw "Seed missing in Release: $n" }
            $seedPaths += $p
          }

          Write-Host "=== Seeds ==="
          $seedPaths | ForEach-Object { Write-Host $_ }

          # Copy seeds + cache.json
          foreach ($s in $seedPaths) { Copy-Item $s $outBin -Force }
          Copy-Item $cacheJson $outBin -Force

          # Dependency closure (only copy deps that exist in $binRel)
          $queue = New-Object System.Collections.Generic.Queue[string]
          $seen  = New-Object 'System.Collections.Generic.HashSet[string]'
          foreach ($s in $seedPaths) {
            $queue.Enqueue($s)
            $null = $seen.Add((Split-Path $s -Leaf).ToLowerInvariant())
          }

          $iter = 0
          while ($queue.Count -gt 0) {
            $iter++
            $cur = $queue.Dequeue()
            $curName = Split-Path $cur -Leaf
            Write-Host "---- Iter $iter: $curName ----"

            $deps = Get-DllDependents $cur
            foreach ($d in $deps) {
              if (IsSystemImport $d) { continue }
              $dl = $d.ToLowerInvariant()
              if ($seen.Contains($dl)) { continue }

              $depPath = Join-Path $binRel $d
              if (Test-Path $depPath) {
                $null = $seen.Add($dl)
                Copy-Item $depPath $outBin -Force
                Write-Host "  +copy $d"
                $queue.Enqueue($depPath)
              } else {
                Write-Host "  skip not-in-package $d"
              }
            }
          }

          # Rewrite plugins.xml: CPU + GPU, location relative to openvino.dll directory
          [xml]$xml = Get-Content $pluginsXml
          $pluginsNode = $xml.SelectSingleNode("//plugins")
          if (-not $pluginsNode) { throw "plugins node not found in plugins.xml" }

          foreach ($p in @($pluginsNode.SelectNodes("plugin"))) { $null = $pluginsNode.RemoveChild($p) }

          # Add CPU plugin
          $cpu = $xml.CreateElement("plugin")
          $cpu.SetAttribute("name","CPU")
          $cpu.SetAttribute("location","openvino_intel_cpu_plugin.dll")
          $null = $pluginsNode.AppendChild($cpu)

          # Add GPU plugin
          $gpu = $xml.CreateElement("plugin")
          $gpu.SetAttribute("name","GPU")
          $gpu.SetAttribute("location","openvino_intel_gpu_plugin.dll")
          $null = $pluginsNode.AppendChild($gpu)

          $outPlugins = Join-Path $outBin "plugins.xml"
          $xml.Save($outPlugins)

          # Copy header
          Copy-Item $ieHeader $outInc -Force

          Write-Host "=== Final output ==="
          Get-ChildItem $outRoot -Recurse | Sort-Object FullName | Format-Table FullName,Length
          Write-Host "=== plugins.xml ==="
          Get-Content $outPlugins

      # ------------------------------------------------------------
      # macOS x86_64: Intel CPU + ONNX frontend
      # Seeds: libopenvino + libopenvino_c + plugins.xml + TBB deps
      #       + libopenvino_intel_cpu_plugin
      #       + libopenvino_onnx_frontend
      # Then: otool closure (only deps resolvable inside extracted runtime tree)
      # Patch: @loader_path everywhere for program-dir loading
      # Rewrite plugins.xml => CPU only, relative location
      # ------------------------------------------------------------
      - name: Extract minimal runtime (macOS, CPU + ONNX, exact seeds + closure + @loader_path)
        if: matrix.platform == 'macos'
        shell: bash
        run: |
          set -euxo pipefail

          runtime_dir="$(find _src -type d -name runtime -maxdepth 6 | head -n 1 || true)"
          [[ -n "$runtime_dir" ]] || (echo "ERROR: runtime dir not found" && exit 1)
          echo "runtime_dir=$runtime_dir"

          # Find lib folder containing libopenvino*.dylib
          lib_rel=""
          for p in \
            "$runtime_dir/lib/intel64/Release" \
            "$runtime_dir/lib/Release" \
            "$runtime_dir/lib"; do
            if [[ -d "$p" ]] && ls "$p"/libopenvino*.dylib >/dev/null 2>&1; then
              lib_rel="$p"; break
            fi
          done
          [[ -n "$lib_rel" ]] || (echo "ERROR: cannot locate lib_rel" && exit 1)
          echo "lib_rel=$lib_rel"
          ls -la "$lib_rel"

          ie_header="$runtime_dir/include/ie/c_api/ie_c_api.h"
          [[ -f "$ie_header" ]] || (echo "ERROR: ie_c_api.h missing" && exit 1)

          plugins_xml="$lib_rel/plugins.xml"
          if [[ ! -f "$plugins_xml" ]]; then
            plugins_xml="$(find "$runtime_dir" -type f -name plugins.xml | head -n 1 || true)"
          fi
          [[ -f "$plugins_xml" ]] || (echo "ERROR: plugins.xml missing" && exit 1)
          echo "plugins.xml=$plugins_xml"

          out="dist/openvino-min-macos"
          out_lib="$out/lib"
          out_inc="$out/include/ie/c_api"
          mkdir -p "$out_lib" "$out_inc"

          # Exact seeds for your scenario (ONNX + CPU + C API)
          seeds=(
            "$lib_rel/libopenvino.dylib"
            "$lib_rel/libopenvino_c.dylib"
            "$lib_rel/libopenvino_intel_cpu_plugin.dylib"
            "$lib_rel/libopenvino_onnx_frontend.dylib"
          )
          for s in "${seeds[@]}"; do
            [[ -f "$s" ]] || (echo "ERROR: seed missing: $s" && exit 1)
          done

          echo "=== Seeds ==="
          printf '%s\n' "${seeds[@]}"

          # closure
          declare -A seen
          queue=()

          copy_one() {
            local src="$1"
            local base
            base="$(basename "$src")"
            if [[ ! -f "$out_lib/$base" ]]; then
              cp -f "$src" "$out_lib/$base"
              echo "  +copy: $base"
            fi
          }

          enqueue() {
            local base
            base="$(basename "$1")"
            if [[ -z "${seen[$base]+x}" ]]; then
              seen["$base"]=1
              queue+=("$1")
            fi
          }

          for s in "${seeds[@]}"; do
            copy_one "$s"
            enqueue "$s"
          done

          iter=0
          while [[ ${#queue[@]} -gt 0 ]]; do
            iter=$((iter+1))
            cur="${queue[0]}"
            queue=("${queue[@]:1}")
            curbase="$(basename "$cur")"
            echo "---- Iter $iter: analyze $curbase ----"

            target="$out_lib/$curbase"
            [[ -f "$target" ]] || continue

            deps="$(otool -L "$target" | tail -n +2 | awk '{print $1}' || true)"
            while IFS= read -r dep; do
              [[ -z "$dep" ]] && continue
              if [[ "$dep" == /usr/lib/* || "$dep" == /System/* ]]; then
                continue
              fi

              resolved=""
              if [[ "$dep" == "$runtime_dir"* && -f "$dep" ]]; then
                resolved="$dep"
              elif [[ "$dep" == @rpath/* ]]; then
                cand="$lib_rel/$(basename "$dep")"
                [[ -f "$cand" ]] && resolved="$cand"
              else
                depbase="$(basename "$dep")"
                cand="$(find "$runtime_dir" -type f -name "$depbase" | head -n 1 || true)"
                [[ -n "$cand" && -f "$cand" ]] && resolved="$cand"
              fi

              if [[ -n "$resolved" ]]; then
                copy_one "$resolved"
                enqueue "$resolved"
              fi
            done <<< "$deps"
          done

          # Rewrite plugins.xml to CPU only, location relative to libopenvino.dylib dir
          cat "$plugins_xml" \
            | perl -0777 -pe 's/<plugin\b[^>]*\/>\s*//sg' \
            | perl -0777 -pe 's!(<plugins[^>]*>)!$1\n    <plugin name="CPU" location="libopenvino_intel_cpu_plugin.dylib"/>\n!s' \
            > "$out_lib/plugins.xml"

          # Patch install names for local loading
          for f in "$out_lib"/*.dylib; do
            [[ -f "$f" ]] || continue
            name="$(basename "$f")"
            install_name_tool -id "@loader_path/$name" "$f" || true
          done

          for f in "$out_lib"/*.dylib; do
            [[ -f "$f" ]] || continue
            deps="$(otool -L "$f" | tail -n +2 | awk '{print $1}' || true)"
            while IFS= read -r dep; do
              [[ -z "$dep" ]] && continue
              if [[ "$dep" == /usr/lib/* || "$dep" == /System/* ]]; then
                continue
              fi
              depbase="$(basename "$dep")"
              if [[ -f "$out_lib/$depbase" ]]; then
                install_name_tool -change "$dep" "@loader_path/$depbase" "$f" || true
              fi
            done <<< "$deps"
          done

          cp -f "$ie_header" "$out_inc/"

          echo "=== Final output ==="
          find "$out" -maxdepth 3 -print
          echo "=== plugins.xml ==="
          cat "$out_lib/plugins.xml"
          echo "=== sample otool ==="
          otool -L "$out_lib/libopenvino.dylib" || true

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: openvino-min-runtime-${{ matrix.platform }}
          path: dist/openvino-min-${{ matrix.platform }}
